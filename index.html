<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>VoxelCraft ‚Äî Patched</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; font-family:'Courier New',monospace; }
  canvas { display:block; }
  #ui { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:white; }
  #crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:24px; height:24px; }
  #crosshair::before { content:''; position:absolute; width:2px; height:24px; background:rgba(255,255,255,.85); left:11px; top:0; box-shadow:0 0 3px rgba(0,0,0,.6); }
  #crosshair::after  { content:''; position:absolute; width:24px; height:2px; background:rgba(255,255,255,.85); left:0; top:11px; box-shadow:0 0 3px rgba(0,0,0,.6); }
  #hotbar { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:5px; background:rgba(0,0,0,.45); padding:6px; border-radius:8px; border:1px solid rgba(255,255,255,.15); pointer-events:all; }
  .hslot { width:52px; height:52px; border:2px solid rgba(255,255,255,.25); border-radius:5px; background:rgba(0,0,0,.5); display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; gap:3px; transition:all .1s; }
  .hslot:hover { border-color:rgba(255,255,255,.6); }
  .hslot.active { border-color:#fff; background:rgba(255,255,255,.18); box-shadow:0 0 12px rgba(255,255,255,.2); }
  .hslot .preview { width:30px; height:30px; border-radius:2px; border:1px solid rgba(0,0,0,.4); image-rendering:pixelated; }
  .hslot .label { font-size:9px; color:rgba(255,255,255,.8); text-align:center; }
  #hud { position:absolute; top:10px; left:10px; font-size:12px; color:rgba(255,255,255,.9); text-shadow:1px 1px 3px black; line-height:1.9; background:rgba(0,0,0,.25); padding:8px 12px; border-radius:6px; }
  #hud .dim { color:rgba(255,255,255,.45); }
  #selected-block { position:absolute; bottom:82px; left:50%; transform:translateX(-50%); font-size:13px; color:rgba(255,255,255,.9); text-shadow:1px 1px 3px black; letter-spacing:1px; }
  #minimap { position:absolute; top:10px; right:10px; width:130px; height:130px; border:2px solid rgba(255,255,255,.2); border-radius:6px; overflow:hidden; background:rgba(0,0,0,.4); }
  #minimap canvas { width:100%; height:100%; image-rendering:pixelated; }

  /* INVENTORY */
  #inv-screen {
    display:none; position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:rgba(20,16,12,0.97);
    border:2px solid rgba(255,255,255,.18);
    border-radius:10px; padding:20px 24px;
    pointer-events:all; min-width:420px;
    box-shadow:0 8px 40px rgba(0,0,0,.7);
  }
  #inv-screen h2 { color:#d4aa70; font-size:15px; letter-spacing:2px; text-transform:uppercase; margin-bottom:14px; text-align:center; }
  .inv-section-label { color:rgba(255,255,255,.4); font-size:10px; letter-spacing:2px; text-transform:uppercase; margin:10px 0 6px; }
  #inv-grid, #hotbar-inv { display:flex; flex-wrap:wrap; gap:5px; }
  #inv-grid { width:306px; }
  .inv-slot {
    width:48px; height:48px;
    border:2px solid rgba(255,255,255,.2); border-radius:5px;
    background:rgba(0,0,0,.45);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    cursor:pointer; position:relative; gap:2px;
    transition:border-color .1s;
  }
  .inv-slot:hover { border-color:rgba(255,255,255,.6); }
  .inv-slot.active { border-color:#fff; }
  .inv-slot img { width:28px; height:28px; image-rendering:pixelated; }
  .inv-slot .count {
    position:absolute; bottom:3px; right:5px;
    font-size:11px; color:#fff; font-weight:bold;
    text-shadow:1px 1px 2px black;
  }
  .inv-slot .sname { font-size:8px; color:rgba(255,255,255,.5); text-align:center; }
  #inv-close { margin-top:14px; width:100%; padding:8px; background:#4a3828; border:none; border-radius:5px; color:#d4aa70; font-size:13px; cursor:pointer; letter-spacing:1px; }
  #inv-close:hover { background:#5a4838; }
  #inv-hint { position:absolute; bottom:82px; right:14px; font-size:11px; color:rgba(255,255,255,.4); text-shadow:1px 1px 2px black; pointer-events:none; }

  /* CRAFTING */
  #craft-screen {
    display:none; position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:rgba(20,16,12,0.97);
    border:2px solid rgba(255,255,255,.18);
    border-radius:10px; padding:20px 24px;
    pointer-events:all; min-width:460px;
    box-shadow:0 8px 40px rgba(0,0,0,.7); color:white;
  }
  #craft-screen h2 { color:#d4aa70; font-size:15px; letter-spacing:2px; text-transform:uppercase; margin-bottom:14px; text-align:center; }
  .craft-row { display:flex; align-items:center; gap:10px; margin-bottom:8px; padding:8px; border-radius:6px; background:rgba(255,255,255,.05); cursor:pointer; transition:background .15s; }
  .craft-row:hover { background:rgba(255,255,255,.12); }
  .craft-row .recipe { display:flex; gap:4px; align-items:center; }
  .craft-row .arrow { color:#d4aa70; font-size:18px; margin:0 6px; }
  .craft-row .result { display:flex; flex-direction:column; align-items:center; gap:2px; }
  .craft-row .result span { font-size:9px; color:rgba(255,255,255,.6); }
  .craft-ingr { width:36px; height:36px; border:1px solid rgba(255,255,255,.2); border-radius:4px; background:rgba(0,0,0,.4); display:flex; align-items:center; justify-content:center; }
  .craft-ingr img { width:28px; height:28px; image-rendering:pixelated; }
  .craft-ingr.empty { opacity:0.2; }
  .craft-qty { font-size:9px; color:rgba(255,255,255,.5); text-align:center; margin-top:2px; }
  .craft-status { font-size:10px; margin-left:auto; padding:3px 8px; border-radius:4px; }
  .craft-status.ok { background:rgba(74,154,40,.4); color:#a0e070; }
  .craft-status.no { background:rgba(154,40,40,.3); color:#e07070; }
  #craft-close { margin-top:12px; width:100%; padding:8px; background:#4a3828; border:none; border-radius:5px; color:#d4aa70; font-size:13px; cursor:pointer; letter-spacing:1px; }
  #craft-close:hover { background:#5a4838; }

  /* OBJECTIVE TRACKER */
  #objective {
    position:absolute; bottom:90px; right:14px;
    font-size:11px; color:rgba(255,255,255,.85); text-shadow:1px 1px 3px black;
    background:rgba(0,0,0,.35); padding:7px 12px; border-radius:6px;
    border-left:3px solid #6abf45; max-width:200px; line-height:1.6;
    pointer-events:none;
  }
  #objective .obj-title { color:#6abf45; font-size:10px; letter-spacing:1px; text-transform:uppercase; margin-bottom:4px; }
  #objective .obj-done  { color:rgba(100,200,100,.7); text-decoration:line-through; }
  #objective .obj-curr  { color:#fff; font-weight:bold; }
  #save-indicator { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:12px; color:rgba(255,255,255,0); text-shadow:1px 1px 3px black; letter-spacing:2px; transition:color .3s; pointer-events:none; }

  /* HUD messages (inventario lleno, errores, etc) */
  #hud-msg { position:absolute; top:50px; left:50%; transform:translateX(-50%); font-size:13px; color:rgba(255,220,80,0); text-shadow:1px 1px 3px black; letter-spacing:1px; transition:color .3s; pointer-events:none; white-space:nowrap; }

  /* DEATH SCREEN */
  #death-screen { display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(180,0,0,0.75); flex-direction:column; align-items:center; justify-content:center; pointer-events:all; }
  #death-screen h2 { font-size:52px; color:#fff; text-shadow:3px 3px 0 #600; margin-bottom:10px; }
  #death-screen p  { font-size:16px; color:rgba(255,200,200,.9); margin-bottom:30px; }
  #death-screen button { padding:12px 36px; background:#a02020; border:none; border-radius:6px; color:white; font-size:16px; cursor:pointer; letter-spacing:1px; }
  #death-screen button:hover { background:#c03030; }
  #overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(160deg,rgba(0,0,0,.88) 0%,rgba(10,30,5,.92) 100%); display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:all; cursor:pointer; }
  #overlay h1 { font-size:58px; font-weight:900; letter-spacing:-2px; color:#6abf45; text-shadow:4px 4px 0 #2d5018, 0 0 40px rgba(106,191,69,.4); margin-bottom:4px; }
  #overlay .sub { color:#a0c880; font-size:13px; letter-spacing:3px; text-transform:uppercase; margin-bottom:6px; }
  #overlay .version { color:#5a8a3c; font-size:11px; letter-spacing:2px; margin-bottom:28px; }
  #overlay .controls { display:grid; grid-template-columns:1fr 1fr; gap:7px 28px; margin-bottom:28px; background:rgba(0,0,0,.4); padding:16px 24px; border-radius:8px; border:1px solid rgba(255,255,255,.1); }
  #overlay .ctrl { font-size:12px; color:#ccc; }
  #overlay .ctrl span { color:#6abf45; font-weight:bold; }
  #overlay .cta { padding:14px 42px; background:#4a9a28; border-radius:6px; font-size:18px; font-weight:bold; color:white; text-shadow:1px 1px 2px rgba(0,0,0,.5); animation:pulse 1.8s ease-in-out infinite; box-shadow:0 4px 20px rgba(74,154,40,.4); letter-spacing:1px; }
  @keyframes pulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:.8;transform:scale(.98)} }
</style>
</head>
<body>
<div id="ui">
  <div id="crosshair"></div>
  <div id="hud">
    <div id="pos">XYZ: 0 / 0 / 0</div>
    <div id="chunk-info">Chunk: 0, 0</div>
    <div id="fps">FPS: --</div>
    <div id="chunk-count" class="dim">Chunks: 0</div>
  </div>
  <div id="health-bar" style="position:absolute;bottom:78px;left:50%;transform:translateX(-50%);display:flex;gap:3px;"></div>
  <div id="selected-block">‚ñ™ GRASS</div>
  <div id="hotbar"></div>
  <div id="inv-hint">E ‚Äî Inventario &nbsp;|&nbsp; C ‚Äî Crafteo</div>
  <div id="objective">
    <div class="obj-title">üéØ Objetivos</div>
    <div id="obj-list"></div>
  </div>
</div>

<div id="save-indicator">üíæ GUARDADO</div>
<div id="hud-msg"></div>

<!-- DEATH SCREEN -->
<div id="death-screen">
  <h2>‚ò† Has muerto</h2>
  <p id="death-msg">Los zombies te encontraron en la oscuridad.</p>
  <button id="respawn-btn">‚Ü© Volver a aparecer</button>
</div>

<!-- INVENTORY -->
<div id="inv-screen">
  <h2>‚öí Inventario</h2>
  <div class="inv-section-label">Mochila</div>
  <div id="inv-grid"></div>
  <div class="inv-section-label">Barra r√°pida</div>
  <div id="hotbar-inv"></div>
  <button id="inv-close">Cerrar (E)</button>
</div>

<!-- CRAFTING -->
<div id="craft-screen">
  <h2>üî® Mesa de Crafteo</h2>
  <div id="craft-list"></div>
  <button id="craft-close">Cerrar (C)</button>
</div>
<div id="minimap"><canvas id="mm" width="130" height="130"></canvas></div>
<div id="overlay">
  <h1>VoxelCraft</h1>
  <div class="sub">Mundo Procedural 3D</div>
  <div class="version">v10.0 ‚Äî Todos los bugs parcheados</div>
  <div class="controls">
    <div class="ctrl"><span>W A S D</span> ‚Äî Moverse</div>
    <div class="ctrl"><span>Espacio</span> ‚Äî Saltar</div>
    <div class="ctrl"><span>Click Izq</span> ‚Äî Romper bloque</div>
    <div class="ctrl"><span>Click Der</span> ‚Äî Colocar bloque</div>
    <div class="ctrl"><span>1‚Äì9</span> ‚Äî Seleccionar bloque</div>
    <div class="ctrl"><span>Shift</span> ‚Äî Correr</div>
  </div>
  <div class="cta">‚ñ∂ Haz click para entrar al mundo</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CONFIG
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CS=16, CH=64, SEA=14;
const RENDER_DIST=7, LOAD_DIST=RENDER_DIST+1;
const SEED=Math.random()*9999|0;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BLOCK TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const B={AIR:0,GRASS:1,DIRT:2,STONE:3,SAND:4,WATER:5,LOG:6,LEAVES:7,SNOW:8,GRAVEL:9};
const BDATA={
  1:{name:'Grass' },2:{name:'Dirt'  },3:{name:'Stone'},
  4:{name:'Sand'  },5:{name:'Water',tp:true,op:0.72},
  6:{name:'Madera'},7:{name:'Hojas',tp:true,op:0.88},
  8:{name:'Nieve' },9:{name:'Grava' },
};
const HOTBAR=[1,2,3,4,6,7,8,9,5];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TEXTURE ATLAS  (256√ó256 = 16√ó16 tiles of 16px each)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const T=16;        // tile size in pixels
const ACOLS=16;    // atlas columns
const AROWS=16;    // atlas rows  (256px / 16px)

// Tile IDs
const TX={
  GRASS_TOP:0, GRASS_SIDE:1, DIRT:2, STONE:3, SAND:4,
  WATER:5, LOG_TOP:6, LOG_SIDE:7, LEAVES:8, SNOW_TOP:9,
  SNOW_SIDE:10, GRAVEL:11, BEDROCK:12, PLANKS:13
};

// face order: [top, bottom, left, right, front, back]
const BLOCK_TEX={
  1:[TX.GRASS_TOP, TX.DIRT,     TX.GRASS_SIDE,TX.GRASS_SIDE,TX.GRASS_SIDE,TX.GRASS_SIDE],
  2:[TX.DIRT,      TX.DIRT,     TX.DIRT,      TX.DIRT,      TX.DIRT,      TX.DIRT      ],
  3:[TX.STONE,     TX.STONE,    TX.STONE,     TX.STONE,     TX.STONE,     TX.STONE     ],
  4:[TX.SAND,      TX.SAND,     TX.SAND,      TX.SAND,      TX.SAND,      TX.SAND      ],
  5:[TX.WATER,     TX.WATER,    TX.WATER,     TX.WATER,     TX.WATER,     TX.WATER     ],
  6:[TX.LOG_TOP,   TX.LOG_TOP,  TX.LOG_SIDE,  TX.LOG_SIDE,  TX.LOG_SIDE,  TX.LOG_SIDE  ],
  7:[TX.LEAVES,    TX.LEAVES,   TX.LEAVES,    TX.LEAVES,    TX.LEAVES,    TX.LEAVES    ],
  8:[TX.SNOW_TOP,  TX.DIRT,     TX.SNOW_SIDE, TX.SNOW_SIDE, TX.SNOW_SIDE, TX.SNOW_SIDE ],
  9:[TX.GRAVEL,    TX.GRAVEL,   TX.GRAVEL,    TX.GRAVEL,    TX.GRAVEL,    TX.GRAVEL    ],
};

// Seeded PRNG per tile
function tileRng(tileId,s=0){ return ()=>{ s=(s+tileId*7919+13)^(s<<5); return (Math.abs(Math.sin(s))*43758.5453)%1; }; }

function buildAtlas(){
  const ac=document.createElement('canvas');
  ac.width=T*ACOLS; ac.height=T*AROWS;
  const ctx=ac.getContext('2d');

  function tile(id,fn){
    const tx=(id%ACOLS)*T, ty=Math.floor(id/ACOLS)*T;
    ctx.save(); ctx.translate(tx,ty); fn(ctx); ctx.restore();
  }

  function noise(ctx,r,g,b,a=1,scale=1){
    for(let y=0;y<T;y++) for(let x=0;x<T;x++){
      const n=(Math.sin((x*scale)*127.1+(y*scale)*311.7)*43758.5453)%1;
      const v=0.8+n*0.4;
      ctx.fillStyle=`rgba(${r*v|0},${g*v|0},${b*v|0},${a})`;
      ctx.fillRect(x,y,1,1);
    }
  }

  function pixelNoise(ctx,paletteFn,density=1){
    for(let y=0;y<T;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*127.1+y*311.7+17)*43758.5453)%1;
      const h2=(Math.sin(x*39.7+y*73.1+5)*43758.5453)%1;
      ctx.fillStyle=paletteFn(h,h2,x,y);
      ctx.fillRect(x,y,1,1);
    }
  }

  // GRASS TOP
  tile(TX.GRASS_TOP, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const g=100+h*60|0, r=40+h2*20|0;
      return `rgb(${r},${g},${r*0.4|0})`;
    });
    // Random bright spots
    for(let i=0;i<12;i++){
      const x=(Math.sin(i*73)*T+T)%T|0, y=(Math.cos(i*37)*T+T)%T|0;
      ctx.fillStyle='rgba(120,200,60,0.35)';
      ctx.fillRect(x,y,1,1);
    }
  });

  // GRASS SIDE
  tile(TX.GRASS_SIDE, ctx=>{
    // Bottom: dirt
    for(let y=3;y<T;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*127.1+y*311.7)*43758.5453)%1;
      const r=100+h*30|0, g=65+h*20|0, b=30+h*10|0;
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      ctx.fillRect(x,y,1,1);
    }
    // Top strip: grass (2-3px)
    for(let y=0;y<3;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*73.1+y*11.7)*43758.5453)%1;
      const jag=(Math.sin(x*2.1)*43758.5453)%1;
      if(y===2 && jag>0.5){ // jagged edge
        const r=100+(h*20|0), g=65+(h*20|0), b=30+(h*10|0);
        ctx.fillStyle=`rgb(${r},${g},${b})`;
      } else {
        const g2=95+(h*55|0);
        ctx.fillStyle=`rgb(${g2*0.35|0},${g2},${g2*0.2|0})`;
      }
      ctx.fillRect(x,y,1,1);
    }
    // Vertical streaks of dirt
    for(let i=0;i<4;i++){
      const x=(i*5+2)%T;
      for(let y=3;y<T;y++){
        ctx.fillStyle='rgba(60,38,12,0.15)';
        ctx.fillRect(x,y,1,1);
      }
    }
  });

  // DIRT
  tile(TX.DIRT, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const r=95+h*35|0, g=62+h*22|0, b=28+h*12|0;
      return `rgb(${r},${g},${b})`;
    });
    // Small stones
    for(let i=0;i<6;i++){
      const x=(Math.sin(i*43)*T+T)%T|0, y=(Math.sin(i*91)*T+T)%T|0;
      ctx.fillStyle='rgba(80,65,50,0.5)';
      ctx.fillRect(x,y,2,1);
    }
  });

  // STONE
  tile(TX.STONE, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const v=105+h*40|0;
      return `rgb(${v},${v},${v})`;
    });
    // Cracks
    const cracks=[[2,2,6,0],[8,5,4,1],[1,10,5,0],[10,12,5,1]];
    cracks.forEach(([sx,sy,len,dir])=>{
      for(let i=0;i<len;i++){
        ctx.fillStyle='rgba(40,40,40,0.7)';
        ctx.fillRect(dir?sx+i:sx, dir?sy:sy+i, 1,1);
      }
    });
  });

  // SAND
  tile(TX.SAND, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const r=195+h*30|0, g=175+h*28|0, b=90+h*25|0;
      return `rgb(${r},${g},${b})`;
    });
    for(let i=0;i<20;i++){
      const x=(Math.sin(i*31)*T+T)%T|0, y=(Math.cos(i*53)*T+T)%T|0;
      ctx.fillStyle='rgba(160,140,60,0.3)';
      ctx.fillRect(x,y,1,1);
    }
  });

  // WATER
  tile(TX.WATER, ctx=>{
    for(let y=0;y<T;y++) for(let x=0;x<T;x++){
      const wave=Math.sin((x+y)*0.8)*0.5+0.5;
      const r=20+wave*15|0, g=100+wave*30|0, b=175+wave*40|0;
      ctx.fillStyle=`rgba(${r},${g},${b},0.9)`;
      ctx.fillRect(x,y,1,1);
    }
    // Highlight lines
    for(let y=0;y<T;y+=4){
      for(let x=0;x<T;x++){
        ctx.fillStyle='rgba(160,220,255,0.25)';
        ctx.fillRect(x,y,1,1);
      }
    }
  });

  // LOG TOP (rings)
  tile(TX.LOG_TOP, ctx=>{
    // Base
    pixelNoise(ctx,(h)=>{ const v=110+h*25|0; return `rgb(${v*0.7|0},${v*0.55|0},${v*0.25|0})`; });
    // Rings
    const cx=T/2, cy=T/2;
    [2,4,6].forEach(r=>{
      for(let a=0;a<360;a+=5){
        const x=cx+Math.cos(a*Math.PI/180)*r|0;
        const y=cy+Math.sin(a*Math.PI/180)*r|0;
        if(x>=0&&x<T&&y>=0&&y<T){
          ctx.fillStyle='rgba(50,30,5,0.5)';
          ctx.fillRect(x,y,1,1);
        }
      }
    });
    // Center
    ctx.fillStyle='rgba(40,25,5,0.7)';
    ctx.fillRect(7,7,2,2);
  });

  // LOG SIDE (vertical bark lines)
  tile(TX.LOG_SIDE, ctx=>{
    pixelNoise(ctx,(h,h2)=>{ const r=115+h*25|0; return `rgb(${r*0.7|0},${r*0.52|0},${r*0.22|0})`; });
    // Vertical dark lines (bark grooves)
    for(let x=0;x<T;x+=3){
      for(let y=0;y<T;y++){
        const d=(Math.sin(y*0.7+x*0.3)*43758.5453)%1;
        ctx.fillStyle=`rgba(30,15,0,${0.3+d*0.3})`;
        ctx.fillRect(x,y,1,1);
      }
    }
    // Horizontal ring lines
    for(let y=0;y<T;y+=5){
      for(let x=0;x<T;x++){
        ctx.fillStyle='rgba(25,12,0,0.35)';
        ctx.fillRect(x,y,1,1);
      }
    }
  });

  // LEAVES
  tile(TX.LEAVES, ctx=>{
    // Transparent base
    ctx.clearRect(0,0,T,T);
    for(let y=0;y<T;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*127.1+y*311.7)*43758.5453)%1;
      const h2=(Math.sin(x*73.1+y*39.7)*43758.5453)%1;
      if(h>0.28){
        const g=85+h*70|0, r=g*0.28|0;
        ctx.fillStyle=`rgba(${r},${g},${r*0.5|0},${0.8+h2*0.2})`;
        ctx.fillRect(x,y,1,1);
      }
    }
    // Small darker leaf shapes
    for(let i=0;i<10;i++){
      const lx=(Math.sin(i*53)*T+T)%T|0, ly=(Math.cos(i*37)*T+T)%T|0;
      ctx.fillStyle='rgba(20,80,15,0.6)';
      ctx.fillRect(lx,ly,2,1); ctx.fillRect(lx,ly+1,1,1);
    }
  });

  // SNOW TOP
  tile(TX.SNOW_TOP, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const v=220+h*30|0, b=230+h2*20|0;
      return `rgb(${v},${v},${b})`;
    });
    // sparkles
    for(let i=0;i<8;i++){
      const x=(Math.sin(i*41)*T+T)%T|0, y=(Math.cos(i*67)*T+T)%T|0;
      ctx.fillStyle='rgba(255,255,255,0.9)';
      ctx.fillRect(x,y,1,1);
    }
  });

  // SNOW SIDE
  tile(TX.SNOW_SIDE, ctx=>{
    // Copy grass_side but top strip = snow
    for(let y=2;y<T;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*127.1+y*311.7)*43758.5453)%1;
      const r=95+h*35|0, g=62+h*22|0, bv=28+h*12|0;
      ctx.fillStyle=`rgb(${r},${g},${bv})`;
      ctx.fillRect(x,y,1,1);
    }
    // Snow cap on top
    for(let y=0;y<3;y++) for(let x=0;x<T;x++){
      const h=(Math.sin(x*73.1+y*11.7)*43758.5453)%1;
      const v=215+h*35|0;
      ctx.fillStyle=`rgb(${v},${v},${v+8>255?255:v+8})`;
      ctx.fillRect(x,y,1,1);
    }
  });

  // GRAVEL
  tile(TX.GRAVEL, ctx=>{
    pixelNoise(ctx,(h,h2)=>{
      const v=100+h*50|0, bv=v-10;
      return `rgb(${v},${v-5},${bv})`;
    });
    // Pebbles
    const pebbles=[[2,2],[5,8],[9,3],[12,11],[3,13],[7,6],[11,14],[1,9],[14,4]];
    pebbles.forEach(([px,py])=>{
      ctx.fillStyle='rgba(70,65,60,0.7)';
      ctx.fillRect(px,py,3,2); ctx.fillRect(px+1,py-1,1,1); ctx.fillRect(px+1,py+2,1,1);
      ctx.fillStyle='rgba(180,170,155,0.5)';
      ctx.fillRect(px,py,1,1);
    });
  });

  return ac;
}

// Build atlas once
const atlasCanvas = buildAtlas();
const atlasTexture = new THREE.CanvasTexture(atlasCanvas);
atlasTexture.magFilter = THREE.NearestFilter;
atlasTexture.minFilter = THREE.NearestFilter;
atlasTexture.generateMipmaps = false;

// Create hotbar previews from atlas
function getBlockPreviewCanvas(bt){
  const tid=BLOCK_TEX[bt]?BLOCK_TEX[bt][0]:0;
  const c=document.createElement('canvas'); c.width=T; c.height=T;
  const ctx=c.getContext('2d');
  const sx=(tid%ACOLS)*T, sy=Math.floor(tid/ACOLS)*T;
  ctx.drawImage(atlasCanvas,sx,sy,T,T,0,0,T,T);
  return c.toDataURL();
}

// UV helpers
function tileUV(tileId){
  const col=tileId%ACOLS, row=Math.floor(tileId/ACOLS);
  const e=0.002; // small epsilon to avoid bleeding
  return {
    u0:col/ACOLS+e, u1:(col+1)/ACOLS-e,
    v0:1-(row+1)/AROWS+e, v1:1-row/AROWS-e
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NOISE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function hash2(x,y){ const n=Math.sin(x*127.1+y*311.7+SEED)*43758.5453; return n-Math.floor(n); }
function smooth(x,y){ const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy,ux=fx*fx*(3-2*fx),uy=fy*fy*(3-2*fy); return hash2(ix,iy)+( hash2(ix+1,iy)-hash2(ix,iy))*ux+(hash2(ix,iy+1)-hash2(ix,iy))*uy+(hash2(ix,iy)-hash2(ix+1,iy)-hash2(ix,iy+1)+hash2(ix+1,iy+1))*ux*uy; }
function fbm(x,y,oct=6){ let v=0,a=0.5,f=1; for(let i=0;i<oct;i++){v+=smooth(x*f,y*f)*a;a*=0.5;f*=2.1;} return v; }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHUNK STORAGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const chunks=new Map();
const pendingMeshRebuild=new Set();
function chunkKey(cx,cz){ return cx+','+cz; }
function worldToChunk(wx,wz){ return [Math.floor(wx/CS),Math.floor(wz/CS)]; }
function localIdx(lx,y,lz){ return lx+lz*CS+y*CS*CS; }

function getChunk(cx,cz){ const k=chunkKey(cx,cz); if(!chunks.has(k)) generateChunk(cx,cz); return chunks.get(k); }

function getBlock(wx,wy,wz){
  if(wy<0||wy>=CH) return wy<0?B.STONE:B.AIR;
  const cx=Math.floor(wx/CS),cz=Math.floor(wz/CS);
  return getChunk(cx,cz).data[localIdx(((wx%CS)+CS)%CS,wy,((wz%CS)+CS)%CS)];
}
function setBlock(wx,wy,wz,type){
  if(wy<0||wy>=CH) return;
  const cx=Math.floor(wx/CS),cz=Math.floor(wz/CS);
  const chunk=getChunk(cx,cz);
  const lx=((wx%CS)+CS)%CS,lz=((wz%CS)+CS)%CS;
  chunk.data[localIdx(lx,wy,lz)]=type;
  chunk.dirty = true; // mark for save
  pendingMeshRebuild.add(chunkKey(cx,cz));
  if(lx===0)    pendingMeshRebuild.add(chunkKey(cx-1,cz));
  if(lx===CS-1) pendingMeshRebuild.add(chunkKey(cx+1,cz));
  if(lz===0)    pendingMeshRebuild.add(chunkKey(cx,cz-1));
  if(lz===CS-1) pendingMeshRebuild.add(chunkKey(cx,cz+1));
}

// ‚îÄ‚îÄ BIOME SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const BIOME = { PLAINS:0, DESERT:1, TUNDRA:2, FOREST:3, OCEAN:4, MOUNTAIN:5 };

function getBiome(wx, wz) {
  const temp  = fbm(wx/120 + 300, wz/120 + 300, 4);
  const humid = fbm(wx/90  + 600, wz/90  + 600, 4);
  const elev  = fbm(wx/28, wz/28, 6);
  if(elev < 0.28) return BIOME.OCEAN;
  if(temp > 0.65 && humid < 0.4) return BIOME.DESERT;
  if(temp < 0.3)  return BIOME.TUNDRA;
  if(elev > 0.72) return BIOME.MOUNTAIN;
  if(humid > 0.6) return BIOME.FOREST;
  return BIOME.PLAINS;
}

// Returns {biome, height, elev} ‚Äî all noise computed once per column
function getBiomeData(wx, wz) {
  const temp  = fbm(wx/120 + 300, wz/120 + 300, 4);
  const humid = fbm(wx/90  + 600, wz/90  + 600, 4);
  const elev  = fbm(wx/28, wz/28, 6);
  let biome;
  if(elev < 0.28)                   biome = BIOME.OCEAN;
  else if(temp > 0.65 && humid<0.4) biome = BIOME.DESERT;
  else if(temp < 0.3)               biome = BIOME.TUNDRA;
  else if(elev > 0.72)              biome = BIOME.MOUNTAIN;
  else if(humid > 0.6)              biome = BIOME.FOREST;
  else                              biome = BIOME.PLAINS;

  let height;
  switch(biome){
    case BIOME.OCEAN:    height=Math.max(2,Math.floor(SEA-4+elev*6)); break;
    case BIOME.DESERT:   height=Math.max(2,Math.floor(SEA+2+elev*10)); break;
    case BIOME.TUNDRA:   height=Math.max(2,Math.floor(SEA+4+elev*14)); break;
    case BIOME.FOREST:   height=Math.max(2,Math.floor(SEA+5+elev*16)); break;
    case BIOME.MOUNTAIN: height=Math.max(2,Math.floor(SEA+14+elev*28)); break;
    default:             height=Math.max(2,Math.floor(SEA+3+elev*18));
  }
  return { biome, height: Math.min(CH-5, height) };
}

// Biome fog/sky tint exposed for day-night blending
const BIOME_TINT = {
  0:'#87CEEB', // plains
  1:'#e8c87a', // desert ‚Äî warm sandy
  2:'#b0cce0', // tundra ‚Äî cold blue-grey
  3:'#6aaa60', // forest ‚Äî green tinge
  4:'#3a8ab0', // ocean ‚Äî deep blue
  5:'#a0b8c8', // mountain ‚Äî grey-blue
};
let currentBiomeTint = new THREE.Color(0x87CEEB);
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function generateChunk(cx,cz){
  const data=new Uint8Array(CS*CS*CH);
  for(let lx=0;lx<CS;lx++) for(let lz=0;lz<CS;lz++){
    const wx=cx*CS+lx, wz=cz*CS+lz;
    const { biome, height } = getBiomeData(wx, wz); // single noise pass
    const isBeach = height <= SEA+1 && biome !== BIOME.OCEAN;

    for(let y=0;y<CH;y++){
      let block=B.AIR;
      if(y===0) { block=B.STONE; }
      else if(y < height-4) { block=B.STONE; }
      else if(y < height-1) {
        switch(biome){
          case BIOME.DESERT:   block=B.SAND;   break;
          case BIOME.TUNDRA:   block=B.GRAVEL; break;
          case BIOME.OCEAN:    block=isBeach?B.SAND:B.DIRT; break;
          default:             block=B.DIRT;
        }
      }
      else if(y < height) {
        switch(biome){
          case BIOME.DESERT:   block=B.SAND;   break;
          case BIOME.TUNDRA:   block=B.GRAVEL; break;
          default:             block=isBeach?B.SAND:B.DIRT;
        }
      }
      else if(y === height) {
        if(isBeach || biome===BIOME.DESERT) block=B.SAND;
        else if(biome===BIOME.TUNDRA || biome===BIOME.MOUNTAIN) block=B.SNOW;
        else block=B.GRASS;
      }
      else if(y<=SEA) { block=B.WATER; }
      data[localIdx(lx,y,lz)]=block;
    }

    // Trees ‚Äî biome specific density & type
    if(height > SEA+1 && biome !== BIOME.DESERT && biome !== BIOME.OCEAN) {
      const tc = hash2(wx*73.1+SEED, wz*39.7+SEED);
      const treeDensity = biome===BIOME.FOREST ? 0.09 : biome===BIOME.PLAINS ? 0.03 : 0.015;
      if(tc < treeDensity) {
        const ty=height+1;
        const th = biome===BIOME.FOREST ? 5+Math.floor(hash2(wx*3,wz*7)*3)
                 : biome===BIOME.TUNDRA ? 3
                 : 4+Math.floor(hash2(wx*3,wz*7)*2);
        for(let t=0;t<th&&ty+t<CH;t++) data[localIdx(lx,ty+t,lz)]=B.LOG;
        const topY=ty+th;
        const radius = biome===BIOME.FOREST ? 3 : 2;
        for(let dx=-radius;dx<=radius;dx++) for(let dz=-radius;dz<=radius;dz++) for(let dy=-1;dy<=2;dy++){
          const gx=wx+dx,gz=wz+dz,gy=topY+dy;
          if(gy<0||gy>=CH) continue;
          const d=Math.abs(dx)+Math.abs(dz)+Math.abs(dy);
          if(d<=radius+1&&(dy<0||Math.abs(dx)<=1||Math.abs(dz)<=1)){
            if(gx>=cx*CS&&gx<(cx+1)*CS&&gz>=cz*CS&&gz<(cz+1)*CS){
              const llx=gx-cx*CS,llz=gz-cz*CS;
              if(data[localIdx(llx,gy,llz)]===B.AIR) data[localIdx(llx,gy,llz)]=B.LEAVES;
            }
          }
        }
      }
    }

    // Desert cacti
    if(biome===BIOME.DESERT && height>SEA) {
      const cc=hash2(wx*51.3+SEED+1, wz*29.7+SEED+1);
      if(cc<0.018) {
        const ch2=2+Math.floor(hash2(wx*5,wz*11)*2);
        for(let t=0;t<ch2&&height+1+t<CH;t++) data[localIdx(lx,height+1+t,lz)]=B.LOG; // reuse log as cactus for now
      }
    }
  }
  const chunk={data,meshes:[],generated:true};
  chunks.set(chunkKey(cx,cz),chunk);
  pendingMeshRebuild.add(chunkKey(cx,cz));
  return chunk;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  THREE.JS SETUP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,.05,400);
const renderer=new THREE.WebGLRenderer({antialias:false}); // no antialias for pixelated look
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

scene.background=new THREE.Color(0x87CEEB);
scene.fog=new THREE.FogExp2(0x87CEEB,0.006);

const sun=new THREE.DirectionalLight(0xfffde7,1.2);
sun.castShadow=true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.near=1;sun.shadow.camera.far=500;
sun.shadow.camera.left=-200;sun.shadow.camera.right=200;
sun.shadow.camera.top=200;sun.shadow.camera.bottom=-200;
scene.add(sun);
const ambientLight=new THREE.AmbientLight(0x8ab4e8,.55);
scene.add(ambientLight);
const hemiLight=new THREE.HemisphereLight(0x87CEEB,0x5a8a3c,.3);
scene.add(hemiLight);

// ‚îÄ‚îÄ DAY/NIGHT SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DAY_DURATION = 600; // 10 min por ciclo completo (5 d√≠a + 5 noche)
let timeOfDay = 0.25;     // 0=midnight, 0.25=sunrise, 0.5=noon, 0.75=sunset

// Moon (simple sphere)
const moonMesh = new THREE.Mesh(
  new THREE.SphereGeometry(8,12,12),
  new THREE.MeshBasicMaterial({color:0xddeeff})
);
scene.add(moonMesh);

// Sun visual (bright sphere)
const sunMesh = new THREE.Mesh(
  new THREE.SphereGeometry(10,12,12),
  new THREE.MeshBasicMaterial({color:0xfffbe0})
);
scene.add(sunMesh);

// Stars
const starGeo = new THREE.BufferGeometry();
const starVerts=[];
for(let i=0;i<1800;i++){
  const theta=Math.random()*Math.PI*2, phi=Math.acos(2*Math.random()-1);
  const r=350;
  starVerts.push(r*Math.sin(phi)*Math.cos(theta), r*Math.cos(phi), r*Math.sin(phi)*Math.sin(theta));
}
starGeo.setAttribute('position',new THREE.Float32BufferAttribute(starVerts,3));
const starField=new THREE.Points(starGeo,new THREE.PointsMaterial({color:0xffffff,size:1.2,sizeAttenuation:true,transparent:true,opacity:0}));
scene.add(starField);

// Sky/fog color keyframes: [time0-1, skyHex, fogHex, sunIntensity, ambientIntensity]
const SKY_KEYS=[
  {t:0.00, sky:new THREE.Color(0x05070f), fog:new THREE.Color(0x05070f), sunI:0,   ambI:0.04, ambC:new THREE.Color(0x111830)},
  {t:0.20, sky:new THREE.Color(0x0a0e20), fog:new THREE.Color(0x0a0e20), sunI:0,   ambI:0.06, ambC:new THREE.Color(0x151f3a)},
  {t:0.25, sky:new THREE.Color(0xf06030), fog:new THREE.Color(0xd05020), sunI:0.3, ambI:0.2,  ambC:new THREE.Color(0xf08040)},
  {t:0.30, sky:new THREE.Color(0x87CEEB), fog:new THREE.Color(0x87CEEB), sunI:1.2, ambI:0.55, ambC:new THREE.Color(0x8ab4e8)},
  {t:0.50, sky:new THREE.Color(0x4fa8e8), fog:new THREE.Color(0x5aafe8), sunI:1.3, ambI:0.6,  ambC:new THREE.Color(0x8ab4e8)},
  {t:0.70, sky:new THREE.Color(0x87CEEB), fog:new THREE.Color(0x87CEEB), sunI:1.1, ambI:0.5,  ambC:new THREE.Color(0x8ab4e8)},
  {t:0.75, sky:new THREE.Color(0xf04010), fog:new THREE.Color(0xd03010), sunI:0.3, ambI:0.2,  ambC:new THREE.Color(0xe06030)},
  {t:0.80, sky:new THREE.Color(0x0a0e20), fog:new THREE.Color(0x0a0e20), sunI:0,   ambI:0.05, ambC:new THREE.Color(0x151f3a)},
  {t:1.00, sky:new THREE.Color(0x05070f), fog:new THREE.Color(0x05070f), sunI:0,   ambI:0.04, ambC:new THREE.Color(0x111830)},
];

// Pre-allocated sky result ‚Äî evita 3 new THREE.Color() por frame
const _skyRes = {
  sky:  new THREE.Color(),
  fog:  new THREE.Color(),
  ambC: new THREE.Color(),
  sunI: 0, ambI: 0, stars: 0
};

function lerpSkyKey(t){
  let a=SKY_KEYS[0],b=SKY_KEYS[1];
  for(let i=0;i<SKY_KEYS.length-1;i++){
    if(t>=SKY_KEYS[i].t && t<=SKY_KEYS[i+1].t){ a=SKY_KEYS[i]; b=SKY_KEYS[i+1]; break; }
  }
  const f=(t-a.t)/(b.t-a.t||0.001);
  _skyRes.sky.lerpColors(a.sky, b.sky, f);
  _skyRes.fog.lerpColors(a.fog, b.fog, f);
  _skyRes.ambC.lerpColors(a.ambC, b.ambC, f);
  _skyRes.sunI = a.sunI+(b.sunI-a.sunI)*f;
  _skyRes.ambI = a.ambI+(b.ambI-a.ambI)*f;
  _skyRes.stars = t<0.25||t>0.75 ? Math.min(1,(t>0.75?(t-0.75)/0.05:(0.25-t)/0.05)) : 0;
  return _skyRes;
}

// HUD time display
const timeEl=document.createElement('div');
timeEl.id='time-display';
timeEl.style.cssText='margin-top:4px;';
document.getElementById('hud').appendChild(timeEl);

function updateDayNight(dt){
  timeOfDay=(timeOfDay+dt/DAY_DURATION)%1;
  const angle=(timeOfDay-0.25)*Math.PI*2; // 0.25 = sunrise east
  const R=200;
  const sx=Math.cos(angle)*R, sy=Math.sin(angle)*R;

  sun.position.set(player.pos.x+sx, sy, player.pos.z+sx*0.3);
  sunMesh.position.copy(sun.position);
  moonMesh.position.set(player.pos.x-sx, -sy, player.pos.z-sx*0.3);
  // Shadow camera sigue al jugador para sombras correctas en exploraci√≥n
  sun.shadow.camera.position.copy(sun.position);
  sun.shadow.camera.lookAt(player.pos);
  sun.shadow.camera.updateMatrixWorld();

  const k=lerpSkyKey(timeOfDay);
  scene.background=k.sky;
  scene.fog.color.copy(k.fog);
  sun.intensity=k.sunI;
  ambientLight.intensity=k.ambI;
  ambientLight.color.copy(k.ambC);
  hemiLight.intensity=k.ambI*0.5;
  hemiLight.color.copy(k.sky);
  starField.material.opacity=k.stars;
  starField.position.copy(player.pos);

  // Sun/moon visibility
  sunMesh.visible  = sy>-20;
  moonMesh.visible = -sy>-20;

  // Time label
  const h=(timeOfDay*24)|0, m=((timeOfDay*24*60)%60)|0;
  const phase=timeOfDay<0.25?'üåô Noche':timeOfDay<0.30?'üåÖ Amanecer':timeOfDay<0.70?'‚òÄÔ∏è D√≠a':timeOfDay<0.80?'üåá Atardecer':'üåô Noche';
  timeEl.textContent=`${phase}  ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ INVENTORY SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const INV_SIZE  = 27; // backpack slots
const HOT_SIZE  = 9;  // hotbar slots

// Each slot: { type: blockId, count: n } or null
const inventory = Array(INV_SIZE).fill(null);
const hotbarInv = Array(HOT_SIZE).fill(null);

// Pre-fill hotbar with one of each for first use
HOTBAR.forEach((bt,i)=>{ hotbarInv[i]={ type:bt, count:1 }; });

let invOpen = false;
let dragItem = null; // { type, count, fromGrid:'inv'|'hot', fromIdx }

function addToInventory(blockType, amount=1) {
  // Apilar en hotbar
  for(let i=0;i<HOT_SIZE;i++) {
    if(hotbarInv[i]?.type===blockType && hotbarInv[i].count<64) {
      hotbarInv[i].count = Math.min(64, hotbarInv[i].count+amount);
      return true;
    }
  }
  // Apilar en mochila
  for(let i=0;i<INV_SIZE;i++) {
    if(inventory[i]?.type===blockType && inventory[i].count<64) {
      inventory[i].count = Math.min(64, inventory[i].count+amount);
      return true;
    }
  }
  // Slot vac√≠o en hotbar
  for(let i=0;i<HOT_SIZE;i++) {
    if(!hotbarInv[i]) { hotbarInv[i]={ type:blockType, count:amount }; return true; }
  }
  // Slot vac√≠o en mochila
  for(let i=0;i<INV_SIZE;i++) {
    if(!inventory[i]) { inventory[i]={ type:blockType, count:amount }; return true; }
  }
  // Inventario lleno ‚Äî avisar en lugar de silenciar
  showHUDMessage('‚ö† Inventario lleno');
  return false;
}

function consumeFromHotbar(slot, amount=1) {
  const s = hotbarInv[slot];
  if(!s) return false;
  s.count -= amount;
  if(s.count <= 0) hotbarInv[slot] = null;
  return true;
}

function getSelectedType() {
  return hotbarInv[selectedSlot]?.type ?? null;
}

// ‚îÄ‚îÄ Inventory UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openInventory() {
  invOpen = true;
  document.exitPointerLock();
  document.getElementById('inv-screen').style.display = 'block';
  renderInvUI();
}
function closeInventory() {
  invOpen = false;
  document.getElementById('inv-screen').style.display = 'none';
  renderer.domElement.requestPointerLock();
}

function renderInvUI() {
  renderSlots('inv-grid', inventory, 'inv');
  renderSlots('hotbar-inv', hotbarInv, 'hot');
}

function renderSlots(containerId, arr, grid) {
  const el = document.getElementById(containerId);
  el.innerHTML = '';
  arr.forEach((slot, i) => {
    const div = document.createElement('div');
    div.className = 'inv-slot' + (grid==='hot' && i===selectedSlot ? ' active' : '');
    if(slot) {
      const img = document.createElement('img');
      img.src = getBlockPreviewCanvas(slot.type);
      div.appendChild(img);
      if(slot.count > 1) {
        const cnt = document.createElement('span');
        cnt.className = 'count'; cnt.textContent = slot.count;
        div.appendChild(cnt);
      }
      const nm = document.createElement('span');
      nm.className = 'sname'; nm.textContent = BDATA[slot.type]?.name || '';
      div.appendChild(nm);
    }
    // Drag & drop
    div.addEventListener('mousedown', e => {
      e.stopPropagation();
      if(slot) { dragItem = { ...slot, fromGrid:grid, fromIdx:i }; arr[i]=null; renderInvUI(); }
    });
    div.addEventListener('mouseup', e => {
      e.stopPropagation();
      if(!dragItem) return;
      const existing = arr[i];
      if(existing && existing.type===dragItem.type && existing.count<64) {
        existing.count = Math.min(64, existing.count+dragItem.count);
      } else if(!existing) {
        arr[i] = { type:dragItem.type, count:dragItem.count };
      } else {
        // Swap back to origin
        const og = dragItem.fromGrid==='inv'?inventory:hotbarInv;
        og[dragItem.fromIdx] = existing;
        arr[i] = { type:dragItem.type, count:dragItem.count };
      }
      dragItem = null;
      renderInvUI();
      rebuildHotbarFromInv();
    });
    el.appendChild(div);
  });
}

function rebuildHotbarFromInv() {
  // Sync hotbarInv ‚Üí hotbar display
  buildHotbarUI();
  refreshHotbar();
}

document.getElementById('inv-close').addEventListener('click', closeInventory);

// CR√çTICO-2 fix: si el usuario suelta el rat√≥n fuera de cualquier slot,
// devolver el item a su slot de origen en lugar de destruirlo
document.addEventListener('mouseup', () => {
  if(!dragItem) return;
  const og = dragItem.fromGrid==='inv' ? inventory : hotbarInv;
  // Solo devolver si el slot de origen est√° vac√≠o (no fue ya rellenado por swap)
  if(!og[dragItem.fromIdx]) {
    og[dragItem.fromIdx] = { type: dragItem.type, count: dragItem.count };
  } else {
    // Buscar primer slot vac√≠o
    const target = dragItem.fromGrid==='inv' ? inventory : hotbarInv;
    const alt = dragItem.fromGrid==='inv' ? hotbarInv : inventory;
    let placed = false;
    for(const arr of [target, alt]) {
      for(let i=0;i<arr.length;i++) {
        if(!arr[i]) { arr[i]={ type:dragItem.type, count:dragItem.count }; placed=true; break; }
        if(arr[i].type===dragItem.type && arr[i].count<64) {
          arr[i].count=Math.min(64,arr[i].count+dragItem.count); placed=true; break;
        }
      }
      if(placed) break;
    }
    if(!placed) showHUDMessage('‚ö† Inventario lleno ‚Äî item recuperado');
  }
  dragItem = null;
  renderInvUI();
  buildHotbarUI(); refreshHotbar();
});
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ PHYSICS SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Blocks affected by gravity
const GRAVITY_BLOCKS = new Set([B.SAND, B.GRAVEL]);
// Water flow: blocks that water can replace
const WATER_REPLACEABLE = new Set([B.AIR]);

// Queue of blocks to simulate next tick
const physicsQueue = new Set();

function queueNeighbors(wx, wy, wz) {
  for(const [dx,dy,dz] of [[0,-1,0],[0,1,0],[-1,0,0],[1,0,0],[0,0,-1],[0,0,1]]) {
    physicsQueue.add(`${wx+dx},${wy+dy},${wz+dz}`);
  }
}

// Called when a block is placed or broken ‚Äî queue its neighbors
const _origSetBlock = setBlock;
// Wrap setBlock to also trigger physics
function setBlockPhysics(wx,wy,wz,type) {
  _origSetBlock(wx,wy,wz,type);
  physicsQueue.add(`${wx},${wy},${wz}`);
  queueNeighbors(wx,wy,wz);
}

// Water flow state: stores "level" 0-7 per water block (0=source, 7=shallowest)
// We store it in a separate Map for now
const waterLevel = new Map(); // "wx,wy,wz" ‚Üí 0..7

function wKey(x,y,z){ return `${x},${y},${z}`; }

function processPhysics() {
  if(physicsQueue.size === 0) return;

  // Process max N blocks per frame to avoid lag
  const toProcess = [...physicsQueue].slice(0, 60);
  physicsQueue.clear();

  for(const key of toProcess) {
    const [wx,wy,wz] = key.split(',').map(Number);
    const b = getBlock(wx,wy,wz);

    // ‚îÄ‚îÄ GRAVITY (sand, gravel) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(GRAVITY_BLOCKS.has(b)) {
      const below = getBlock(wx, wy-1, wz);
      if(below === B.AIR || below === B.WATER) {
        setBlock(wx, wy, wz, B.AIR);
        setBlock(wx, wy-1, wz, b);
        waterLevel.delete(wKey(wx,wy,wz));
        pendingMeshRebuild.add(chunkKey(Math.floor(wx/CS), Math.floor(wz/CS)));
        // Keep falling next tick
        physicsQueue.add(`${wx},${wy-1},${wz}`);
        queueNeighbors(wx, wy, wz);
        continue;
      }
    }

    // ‚îÄ‚îÄ WATER FLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(b === B.WATER) {
      const level = waterLevel.get(wKey(wx,wy,wz)) ?? 0;
      if(level >= 7) continue; // too shallow to spread

      // Try to flow DOWN first
      const below = getBlock(wx, wy-1, wz);
      if(below === B.AIR) {
        setBlock(wx, wy-1, wz, B.WATER);
        waterLevel.set(wKey(wx,wy-1,wz), 0); // full when falling down
        pendingMeshRebuild.add(chunkKey(Math.floor(wx/CS), Math.floor(wz/CS)));
        physicsQueue.add(`${wx},${wy-1},${wz}`);
        continue;
      }

      // Spread horizontally if level < 6
      if(level < 6) {
        for(const [dx,,dz] of [[-1,0,0],[1,0,0],[0,0,-1],[0,0,1]]) {
          const nx=wx+dx, nz=wz+dz;
          const nb = getBlock(nx, wy, nz);
          if(nb === B.AIR) {
            const newLevel = level + 1;
            const existing = waterLevel.get(wKey(nx,wy,nz)) ?? 99;
            if(newLevel < existing) {
              setBlock(nx, wy, nz, B.WATER);
              waterLevel.set(wKey(nx,wy,nz), newLevel);
              pendingMeshRebuild.add(chunkKey(Math.floor(nx/CS), Math.floor(nz/CS)));
              physicsQueue.add(`${nx},${wy},${nz}`);
            }
          }
        }
      }
    }
  }
}

// Player swimming ‚Äî slow down in water
function isPlayerInWater() {
  return getBlock(Math.floor(player.pos.x), Math.floor(player.pos.y+0.5), Math.floor(player.pos.z)) === B.WATER;
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ MOB SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _mobMatCache = {};
function getMobMat(color) {
  if(!_mobMatCache[color]) _mobMatCache[color] = new THREE.MeshLambertMaterial({ color });
  return _mobMatCache[color];
}
const MOB_TYPES = {
  cow:     { color:0xeeeeee, legCol:0xcccccc, size:[0.9,0.7,1.4], speed:1.5, hostile:false, hp:10, drops:'ü•©' },
  pig:     { color:0xffb6c1, legCol:0xee9090, size:[0.8,0.6,1.1], speed:1.8, hostile:false, hp:8,  drops:'ü•ì' },
  zombie:  { color:0x4a9a4a, legCol:0x2a6a2a, size:[0.6,1.8,0.6], speed:1.2, hostile:true,  hp:20, drops:'üíÄ' },
  skeleton:{ color:0xddddcc, legCol:0xbbbbaa, size:[0.5,1.7,0.5], speed:1.5, hostile:true,  hp:15, drops:'ü¶¥' },
};

const mobs = [];
let playerHP = 20, playerMaxHP = 20, lastDmgTime = 0;

// Build a mob mesh (body + head + 4 legs)
function makeMobMesh(type) {
  const def = MOB_TYPES[type];
  const [bw,bh,bd] = def.size;
  const group = new THREE.Group();

  const bodyMat = getMobMat(def.color);
  const legMat  = getMobMat(def.legCol);
  const headMat = getMobMat(def.color);
  const eyeMat  = getMobMat(0x111111);

  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(bw,bh,bd), bodyMat);
  body.position.y = bh/2 + 0.4;
  body.castShadow = true;
  group.add(body);

  // Head
  const hs = Math.max(bw, 0.55);
  const head = new THREE.Mesh(new THREE.BoxGeometry(hs,hs,hs), headMat);
  head.position.y = bh + hs/2 + 0.4;
  head.castShadow = true;
  group.add(head);

  // Eyes
  [-0.15,0.15].forEach(ex => {
    const eye = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.05), eyeMat);
    eye.position.set(ex, bh+hs*0.6+0.4, hs/2+0.01);
    group.add(eye);
  });

  // Legs
  const lw=0.22, lh=0.4;
  const legPositions = type==='cow'||type==='pig'
    ? [[-bw/3,0,-bd/3],[bw/3,0,-bd/3],[-bw/3,0,bd/3],[bw/3,0,bd/3]]
    : [[-0.15,0,-0.1],[0.15,0,-0.1],[-0.15,0,0.1],[0.15,0,0.1]];

  const legs = [];
  legPositions.forEach(([lx,,lz]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(lw,lh,lw), legMat);
    leg.position.set(lx, lh/2, lz);
    leg.castShadow = true;
    group.add(leg);
    legs.push(leg);
  });

  group.userData.legs = legs;
  group.userData.headMesh = head;
  return group;
}

function spawnMob(type, x, z) {
  // Find surface Y
  let sy = 0;
  for(let y=CH-1;y>=0;y--) {
    const b=getBlock(x,y,z);
    if(b!==B.AIR&&b!==B.WATER) { sy=y+1; break; }
  }
  if(sy===0) return;

  const def = MOB_TYPES[type];
  const mesh = makeMobMesh(type);
  mesh.position.set(x+0.5, sy, z+0.5);
  scene.add(mesh);

  mobs.push({
    type, mesh, def,
    pos: new THREE.Vector3(x+0.5, sy, z+0.5),
    vel: new THREE.Vector3(),
    hp: def.hp,
    alive: true,
    walkTimer: Math.random()*3,
    walkDir: new THREE.Vector2(Math.random()-0.5, Math.random()-0.5).normalize(),
    walkTime: 0,
    attackCooldown: 0,
    legPhase: 0,
    aggro: false,
  });
}

function initialSpawnMobs() {
  const types = ['cow','pig','cow','pig','zombie','skeleton'];
  for(let i=0; i<18; i++) {
    const angle = Math.random()*Math.PI*2;
    const dist  = 8 + Math.random()*40;
    const x = Math.floor(8 + Math.cos(angle)*dist);
    const z = Math.floor(8 + Math.sin(angle)*dist);
    const type = types[i%types.length];
    // Zombies/skeletons only spawn at night initially ‚Äî delay check handled in update
    spawnMob(type, x, z);
  }
}

// Nameplate / damage display
function showDamage(pos, dmg) {
  // simple: flash a div
  const el = document.createElement('div');
  el.textContent = `-${dmg}`;
  el.style.cssText = `position:absolute;color:#ff4444;font-size:18px;font-weight:bold;text-shadow:1px 1px 3px black;pointer-events:none;transition:transform 1s,opacity 1s;`;
  const sc = renderer.domElement.getBoundingClientRect();
  el.style.left = sc.width/2 + 'px';
  el.style.top  = sc.height/2 - 40 + 'px';
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.transform='translateY(-40px)'; el.style.opacity='0'; },50);
  setTimeout(()=>el.remove(), 1100);
}

function updateHealthBar() {
  const hb = document.getElementById('health-bar');
  hb.innerHTML = '';
  for(let i=0;i<10;i++) {
    const hearts = Math.ceil(playerHP/2);
    const full = i < Math.floor(playerHP/2);
    const half = !full && i < Math.ceil(playerHP/2);
    const el = document.createElement('span');
    el.style.fontSize='16px';
    el.textContent = full ? '‚ù§Ô∏è' : half ? 'ü©∑' : 'üñ§';
    hb.appendChild(el);
  }
}

function updateMobs(dt) {
  const isNight = timeOfDay < 0.25 || timeOfDay > 0.75;
  const pp = player.pos;

  // Spawn control ‚Äî keep ~12 mobs cerca
  const aliveMobCount = mobs.reduce((n,m)=>n+(m.alive?1:0),0);
  if(aliveMobCount < 12 && Math.random()<0.01) {
    const angle=Math.random()*Math.PI*2, dist=16+Math.random()*24;
    const x=Math.floor(pp.x+Math.cos(angle)*dist);
    const z=Math.floor(pp.z+Math.sin(angle)*dist);
    const type = isNight
      ? (Math.random()<0.5?'zombie':'skeleton')
      : (Math.random()<0.5?'cow':'pig');
    spawnMob(type, x, z);
  }

  // Burn hostile mobs in daylight
  for(const mob of mobs) {
    if(!mob.alive) continue;
    if(mob.def.hostile && !isNight) {
      mob.hp -= dt*4;
      if(mob.hp<=0) { killMob(mob); continue; }
    }
  }

  lastDmgTime += dt;

  for(const mob of mobs) {
    if(!mob.alive) continue;
    const dist = mob.pos.distanceTo(pp);

    // Aggro logic
    if(mob.def.hostile && dist < 24) mob.aggro = true;
    if(dist > 40) mob.aggro = false;

    // Attack player
    if(mob.def.hostile && mob.aggro && dist < 1.5 && mob.attackCooldown<=0 && lastDmgTime>1) {
      playerHP = Math.max(0, playerHP-2);
      lastDmgTime = 0;
      mob.attackCooldown = 1.2;
      updateHealthBar();
      if(playerHP <= 0) { triggerDeath(); return; }
      // Knockback solo si sigue vivo
      const kdir = pp.clone().sub(mob.pos).normalize();
      player.vel.x += kdir.x*5; player.vel.z += kdir.z*5; player.vel.y=4;
      playTone(180,'sawtooth',0.15,0.1); // hit sound
    }
    mob.attackCooldown = Math.max(0, mob.attackCooldown-dt);

    // Movement
    mob.walkTimer -= dt;
    if(mob.walkTimer <= 0) {
      mob.walkDir.set(Math.random()-0.5, Math.random()-0.5).normalize();
      mob.walkTimer = 2 + Math.random()*4;
      mob.walkTime  = 1 + Math.random()*3;
    }

    let mx=0, mz=0;
    if(mob.walkTime > 0) {
      mob.walkTime -= dt;
      if(mob.aggro && mob.def.hostile) {
        // Chase player
        const toP = new THREE.Vector2(pp.x-mob.pos.x, pp.z-mob.pos.z).normalize();
        mx = toP.x; mz = toP.y;
      } else {
        mx = mob.walkDir.x; mz = mob.walkDir.y;
      }
    }

    const spd = mob.def.speed * (mob.aggro?1.6:1);
    mob.pos.x += mx*spd*dt;
    mob.pos.z += mz*spd*dt;

    // Simple ground snap
    const gx=Math.floor(mob.pos.x), gz=Math.floor(mob.pos.z);
    for(let y=Math.floor(mob.pos.y)+2;y>=0;y--) {
      const b=getBlock(gx,y,gz);
      if(b!==B.AIR&&b!==B.WATER) { mob.pos.y=y+1; break; }
    }

    // Update mesh position
    mob.mesh.position.copy(mob.pos);

    // Rotate toward movement direction
    if(Math.abs(mx)>0.01||Math.abs(mz)>0.01)
      mob.mesh.rotation.y = Math.atan2(mx, mz);

    // Leg animation
    mob.legPhase += dt * spd * 4;
    mob.mesh.userData.legs.forEach((leg,i) => {
      leg.rotation.x = Math.sin(mob.legPhase + i*Math.PI) * 0.5;
    });

    // Head look at player (hostile)
    if(mob.def.hostile && mob.aggro) {
      const head = mob.mesh.userData.headMesh;
      const dy = pp.y - mob.pos.y;
      head.rotation.x = Math.atan2(dy, Math.max(1, dist)) * 0.5;
    }
  }

  // Limpiar mobs: muertos O demasiado lejos
  for(let i=mobs.length-1;i>=0;i--) {
    const m=mobs[i];
    if(!m.alive || m.pos.distanceTo(pp) > 80) {
      scene.remove(m.mesh);
      // Dispose geometries
      m.mesh.traverse(c=>{ if(c.geometry) c.geometry.dispose(); });
      mobs.splice(i,1);
    }
  }
}

function killMob(mob) {
  mob.alive = false;
  scene.remove(mob.mesh);
  mob.mesh.traverse(c=>{ if(c.geometry) c.geometry.dispose(); });
  if(mob.def.hostile) { _stats.mobsKilled++; updateObjectives(); }
  // Drop label
  const el = document.createElement('div');
  el.textContent = mob.def.drops + ' drop!';
  el.style.cssText = 'position:absolute;color:#ffdd00;font-size:15px;font-weight:bold;text-shadow:1px 1px 3px black;pointer-events:none;left:50%;transform:translateX(-50%);transition:all 1.2s;';
  el.style.top = '42%';
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.top='38%'; el.style.opacity='0'; },50);
  setTimeout(()=>el.remove(), 1300);
}

// Left click on mob = hit mob
function tryHitMob() {
  const dir=new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch,yaw,0,'YXZ'));
  const o=player.pos.clone().add(new THREE.Vector3(0,player.EYE,0));
  let best=null, bestD=5;
  for(const mob of mobs) {
    if(!mob.alive) continue;
    const toMob=mob.pos.clone().setY(mob.pos.y+1).sub(o);
    const d=toMob.length();
    const dot=toMob.normalize().dot(dir);
    if(dot>0.92 && d<bestD) { best=mob; bestD=d; }
  }
  if(best) {
    const tool = TOOLS[getSelectedType()];
    const bonus = tool?.attackBonus || 0;
    const dmg = 5 + bonus;
    best.hp -= dmg;
    showDamage(best.pos, dmg);
    if(best.hp<=0) killMob(best);
  }
  return !!best;
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const hlMesh=new THREE.Mesh(
  new THREE.BoxGeometry(1.01,1.01,1.01),
  new THREE.MeshBasicMaterial({color:0x000000,wireframe:true,transparent:true,opacity:0.4})
);
hlMesh.visible=false;
scene.add(hlMesh);

// Clouds ‚Äî follow player
const cloudMeshes = [];
const cloudOffsets = [];
(function(){
  const cg=new THREE.PlaneGeometry(10,6);
  const cm=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.65,side:THREE.DoubleSide});
  for(let i=0;i<30;i++){
    const c=new THREE.Mesh(cg,cm); c.rotation.x=Math.PI/2;
    const ox=(Math.random()-.5)*300, oz=(Math.random()-.5)*300;
    cloudOffsets.push({x:ox, z:oz, y:48+Math.random()*10});
    c.position.set(ox, cloudOffsets[i].y, oz);
    scene.add(c);
    cloudMeshes.push(c);
  }
})();

// Shared materials
const matOpaque=new THREE.MeshLambertMaterial({ map:atlasTexture, side:THREE.FrontSide });
const matTransparent=new THREE.MeshLambertMaterial({ map:atlasTexture, transparent:true, opacity:1, alphaTest:0.1, side:THREE.DoubleSide, depthWrite:false });

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MESH BUILDER (UV-based)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const FACES=[
  { fi:0, d:[0,1,0],  c:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], sh:1.00 }, // top
  { fi:1, d:[0,-1,0], c:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], sh:0.65 }, // bottom (brighter)
  { fi:2, d:[-1,0,0], c:[[0,0,0],[0,1,0],[0,1,1],[0,0,1]], sh:0.78 }, // left
  { fi:3, d:[1,0,0],  c:[[1,0,1],[1,1,1],[1,1,0],[1,0,0]], sh:0.78 }, // right
  { fi:4, d:[0,0,-1], c:[[1,0,0],[1,1,0],[0,1,0],[0,0,0]], sh:0.90 }, // front
  { fi:5, d:[0,0,1],  c:[[0,0,1],[0,1,1],[1,1,1],[1,0,1]], sh:0.68 }, // back
];

function isTransparentBlock(b){ return b===B.AIR||b===B.WATER||b===B.LEAVES; }

function shouldSkipFace(bt, nb) {
  // Same block ‚Üí always skip (internal water-water, leaves-leaves)
  if(bt === nb) return true;
  // Opaque block: skip if neighbor is also opaque
  if(!isTransparentBlock(bt)) return !isTransparentBlock(nb);
  // Transparent block (water/leaves): only skip if neighbor is same type (handled above)
  // Always render against AIR and against opaque blocks (so water shows sides vs terrain)
  return false;
}

function buildChunkMesh(cx,cz){
  const chunk=chunks.get(chunkKey(cx,cz));
  if(!chunk) return;
  for(const m of chunk.meshes){ m.geometry.dispose(); scene.remove(m); }
  chunk.meshes=[];

  const ox=cx*CS, oz=cz*CS;
  // Two arrays: opaque and transparent
  const aPos=[],aUV=[],aNor=[],aIdx=[];
  const tPos=[],tUV=[],tNor=[],tIdx=[];
  let vi=0, tvi=0;

  for(let lx=0;lx<CS;lx++) for(let y=0;y<CH;y++) for(let lz=0;lz<CS;lz++){
    const bt=chunk.data[localIdx(lx,y,lz)];
    if(bt===B.AIR) continue;
    const isTP=bt===B.WATER||bt===B.LEAVES;
    const wx=ox+lx, wz=oz+lz;
    const texFaces=BLOCK_TEX[bt]||[0,0,0,0,0,0];

    for(let fi=0;fi<6;fi++){
      const f=FACES[fi];
      const nb=getBlock(wx+f.d[0],y+f.d[1],wz+f.d[2]);
      if(shouldSkipFace(bt, nb)) continue;
      if(bt===B.WATER&&fi===0&&getBlock(wx,y+1,wz)===B.WATER) continue;

      const tid=texFaces[fi];
      const uv=tileUV(tid);
      // UV corners: [u0,v1],[u1,v1],[u1,v0],[u0,v0]
      const uvs=[[uv.u0,uv.v1],[uv.u1,uv.v1],[uv.u1,uv.v0],[uv.u0,uv.v0]];

      const pos=isTP?tPos:aPos;
      const uvA=isTP?tUV:aUV;
      const nor=isTP?tNor:aNor;
      const idx=isTP?tIdx:aIdx;
      const v=isTP?tvi:vi;

      for(let ci=0;ci<4;ci++){
        const co=f.c[ci];
        pos.push(wx+co[0], y+co[1], wz+co[2]);
        uvA.push(uvs[ci][0], uvs[ci][1]);
        nor.push(f.d[0],f.d[1],f.d[2]);
      }
      idx.push(v,v+1,v+2,v,v+2,v+3);
      if(isTP) tvi+=4; else vi+=4;
    }
  }

  function makeMesh(pos,uvA,nor,idx,mat){
    if(idx.length===0) return null;
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
    geo.setAttribute('uv',      new THREE.Float32BufferAttribute(uvA,2));
    geo.setAttribute('normal',  new THREE.Float32BufferAttribute(nor,3));
    geo.setIndex(idx);
    geo.computeBoundingSphere();
    const m=new THREE.Mesh(geo,mat);
    m.castShadow=true; m.receiveShadow=true;
    scene.add(m);
    return m;
  }

  const m1=makeMesh(aPos,aUV,aNor,aIdx,matOpaque);
  const m2=makeMesh(tPos,tUV,tNor,tIdx,matTransparent);
  if(m1){ m1.renderOrder=0; chunk.meshes.push(m1); }
  if(m2){ m2.renderOrder=1; chunk.meshes.push(m2); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHUNK MANAGER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let lastPCX=null,lastPCZ=null;
function updateChunks(px,pz){
  const [pcx,pcz]=worldToChunk(px,pz);
  for(const [key,chunk] of chunks){
    const [cx,cz]=key.split(',').map(Number);
    if(Math.abs(cx-pcx)>LOAD_DIST+1||Math.abs(cz-pcz)>LOAD_DIST+1){
      for(const m of chunk.meshes){ m.geometry.dispose(); scene.remove(m); }
      chunks.delete(key);
    }
  }
  for(let dx=-LOAD_DIST;dx<=LOAD_DIST;dx++) for(let dz=-LOAD_DIST;dz<=LOAD_DIST;dz++){
    if(dx*dx+dz*dz>LOAD_DIST*LOAD_DIST) continue;
    const k=chunkKey(pcx+dx,pcz+dz);
    if(!chunks.has(k)) generateChunk(pcx+dx,pcz+dz);
  }
}
function processMeshQueue(max=4){
  let n=0;
  for(const key of pendingMeshRebuild){
    if(n>=max) break;
    if(chunks.has(key)){ const [cx,cz]=key.split(',').map(Number); buildChunkMesh(cx,cz); n++; }
    pendingMeshRebuild.delete(key);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PLAYER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const player={pos:new THREE.Vector3(8,30,8),vel:new THREE.Vector3(),onGround:false,EYE:1.62,SPEED:5.5,JUMP:8.5};
function findSpawn(){
  for(let y=CH-1;y>=0;y--){
    const b=getBlock(8,y,8);
    if(b!==B.AIR&&b!==B.WATER){
      player.pos.set(8.5,y+2.2,8.5);
      spawnX=8.5; spawnY=y+2.2; spawnZ=8.5;
      return;
    }
  }
}
function isSolid(wx,wy,wz){ const b=getBlock(wx,wy,wz); return b!==B.AIR&&b!==B.WATER&&b!==B.LEAVES; }
function collidesPlayer(){
  const {x,y,z}=player.pos,R=0.3;
  for(const ox of[-R,R]) for(const oz of[-R,R]) for(let dy=0;dy<2;dy++) if(isSolid(Math.floor(x+ox),Math.floor(y+dy*.95),Math.floor(z+oz))) return true;
  return false;
}
const keys={};
let yaw=0,pitch=0,locked=false,selectedSlot=0;
function movePlayer(dt){
  const fwd=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  const rgt=new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
  const mv=new THREE.Vector3();
  if(keys['KeyW']) mv.add(fwd); if(keys['KeyS']) mv.sub(fwd);
  if(keys['KeyA']) mv.sub(rgt); if(keys['KeyD']) mv.add(rgt);
  const sp=keys['ShiftLeft']?1.75:1;
  const inWater = isPlayerInWater();
  const waterMult = inWater ? 0.45 : 1;
  if(mv.lengthSq()>0) mv.normalize().multiplyScalar(player.SPEED*sp*waterMult);
  player.vel.x=mv.x; player.vel.z=mv.z;
  // In water: float up with Space, reduce gravity
  if(inWater) {
    player.vel.y *= 0.85;
    if(keys['Space']) player.vel.y = 3.5;
    else player.vel.y -= 6*dt;
  } else {
    if(keys['Space']&&player.onGround){player.vel.y=player.JUMP;player.onGround=false;}
    player.vel.y-=22*dt;
  } player.vel.y=Math.max(player.vel.y,-50);
  player.pos.x+=player.vel.x*dt; if(collidesPlayer()){player.pos.x-=player.vel.x*dt;player.vel.x=0;}
  player.pos.z+=player.vel.z*dt; if(collidesPlayer()){player.pos.z-=player.vel.z*dt;player.vel.z=0;}
  player.pos.y+=player.vel.y*dt; if(collidesPlayer()){if(player.vel.y<0)player.onGround=true;player.pos.y-=player.vel.y*dt;player.vel.y=0;}else{player.onGround=false;}
  player.pos.y=Math.max(0,player.pos.y);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RAYCAST
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function raycast(){
  const dir=new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch,yaw,0,'YXZ'));
  const o=player.pos.clone().add(new THREE.Vector3(0,player.EYE,0));
  let prev=null;
  for(let i=1;i<=130;i++){
    const p=o.clone().addScaledVector(dir,.04*i);
    const bx=Math.floor(p.x),by=Math.floor(p.y),bz=Math.floor(p.z);
    const b=getBlock(bx,by,bz);
    if(b!==B.AIR&&b!==B.WATER&&b!==B.LEAVES) return{hit:{x:bx,y:by,z:bz},prev};
    prev={x:bx,y:by,z:bz};
  }
  return null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CONTROLS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='Escape') {
    if(invOpen)   closeInventory();
    if(craftOpen) closeCraft();
  }
  if(e.code==='KeyE' && !isDead){ invOpen ? closeInventory() : openInventory(); }
  if(e.code==='KeyC' && !isDead){ craftOpen ? closeCraft() : openCraft(); }
  if(e.code==='KeyS' && e.ctrlKey){ e.preventDefault(); saveGame(); }
});
document.addEventListener('keyup',  e=>{keys[e.code]=false;});
document.addEventListener('keydown',e=>{
  if(e.code.startsWith('Digit')){ const n=parseInt(e.code.replace('Digit',''))-1; if(n>=0&&n<HOTBAR.length){selectedSlot=n;refreshHotbar();} }
});
document.addEventListener('wheel',e=>{selectedSlot=(selectedSlot+Math.sign(e.deltaY)+HOTBAR.length)%HOTBAR.length;refreshHotbar();},{passive:true});
document.addEventListener('mousemove',e=>{
  if(!locked) return;
  yaw-=e.movementX*.0022; pitch-=e.movementY*.0022;
  pitch=Math.max(-Math.PI/2+.01,Math.min(Math.PI/2-.01,pitch));
});
const overlay=document.getElementById('overlay');
overlay.addEventListener('click',()=>renderer.domElement.requestPointerLock());
document.addEventListener('pointerlockchange',()=>{
  locked=document.pointerLockElement===renderer.domElement;
  overlay.style.display=locked?'none':'flex';
});
document.addEventListener('mousedown',e=>{
  if(!locked) return;
  const rc=raycast(); if(!rc) return;
  if(e.button===0){
    if(tryHitMob()) return;
    const broken = getBlock(rc.hit.x,rc.hit.y,rc.hit.z);
    setBlockPhysics(rc.hit.x,rc.hit.y,rc.hit.z,B.AIR);
    if(broken!==B.AIR && broken!==B.WATER) {
      addToInventory(broken, 1);
      if(broken===B.STONE) _stats.stoneMined++;
      playBreakSound(broken);
      buildHotbarUI(); refreshHotbar();
      updateObjectives();
      checkNewRecipes();
    }
  }
  else if(e.button===2&&rc.prev){
    const{x,y,z}=rc.prev;
    const px=Math.floor(player.pos.x),py=Math.floor(player.pos.y),pz=Math.floor(player.pos.z);
    if(x===px&&z===pz&&(y===py||y===py+1)) return;
    const placed = getSelectedType();
    if(!placed) return;
    setBlockPhysics(x,y,z,placed);
    if(placed===B.WATER) waterLevel.set(wKey(x,y,z), 0);
    _stats.blocksPlaced++;
    playPlaceSound(placed);
    consumeFromHotbar(selectedSlot, 1);
    buildHotbarUI(); refreshHotbar();
    updateObjectives();
  }
});
document.addEventListener('contextmenu',e=>e.preventDefault());

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HOTBAR UI
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildHotbarUI(){
  const hb=document.getElementById('hotbar'); hb.innerHTML='';
  hotbarInv.forEach((slot,i)=>{
    const div=document.createElement('div');
    div.className='hslot'+(i===selectedSlot?' active':'');
    if(slot){
      const preview=getBlockPreviewCanvas(slot.type);
      div.innerHTML=`<img class="preview" src="${preview}" style="image-rendering:pixelated"><div class="label">${BDATA[slot.type]?.name||''}</div>`;
      if(slot.count>1){
        const cnt=document.createElement('span');
        cnt.style.cssText='position:absolute;bottom:3px;right:5px;font-size:10px;color:#fff;font-weight:bold;text-shadow:1px 1px 2px black;';
        cnt.textContent=slot.count; div.style.position='relative'; div.appendChild(cnt);
      }
    }
    div.addEventListener('click',()=>{selectedSlot=i;refreshHotbar();if(!locked)renderer.domElement.requestPointerLock();});
    hb.appendChild(div);
  });
}
function refreshHotbar(){
  document.querySelectorAll('.hslot').forEach((el,i)=>el.className='hslot'+(i===selectedSlot?' active':''));
  const slot=hotbarInv[selectedSlot];
  document.getElementById('selected-block').textContent= slot ? `‚ñ™ ${BDATA[slot.type]?.name?.toUpperCase()}` : '‚ñ™ ‚Äî';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MINIMAP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const mmCanvas=document.getElementById('mm'),mmCtx=mmCanvas.getContext('2d');
const MM=130;
const MINIMAP_COLS={1:'#5d9e3b',2:'#8B5E3C',3:'#7a7a7a',4:'#c8b560',5:'#1a72b0',6:'#7a4010',7:'#2d8a1e',8:'#e2eaf5',9:'#888076'};
function drawMinimap(){
  const px=Math.floor(player.pos.x),pz=Math.floor(player.pos.z);
  const imgData=mmCtx.createImageData(MM,MM);
  for(let py2=0;py2<MM;py2++) for(let px2=0;px2<MM;px2++){
    const bwx=Math.round(px+(px2-MM/2)),bwz=Math.round(pz+(py2-MM/2));
    let r=50,g=50,b=50;
    for(let y=CH-1;y>=0;y--){
      const blk=getBlock(bwx,y,bwz);
      if(blk===B.AIR) continue;
      const hex=MINIMAP_COLS[blk]||'#888';
      const c=new THREE.Color(hex);
      const shade=Math.min(1,.4+y/CH*.8);
      r=c.r*255*shade|0; g=c.g*255*shade|0; b=c.b*255*shade|0; break;
    }
    const idx=(py2*MM+px2)*4;
    imgData.data[idx]=r;imgData.data[idx+1]=g;imgData.data[idx+2]=b;imgData.data[idx+3]=255;
  }
  mmCtx.putImageData(imgData,0,0);
  mmCtx.fillStyle='#ff4444';
  mmCtx.beginPath();mmCtx.arc(MM/2,MM/2,3,0,Math.PI*2);mmCtx.fill();
  mmCtx.strokeStyle='#ff4444';mmCtx.lineWidth=2;
  mmCtx.beginPath();mmCtx.moveTo(MM/2,MM/2);mmCtx.lineTo(MM/2-Math.sin(yaw)*9,MM/2-Math.cos(yaw)*9);mmCtx.stroke();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MAIN LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let last=performance.now(),frames=0,fpsT=0,fps=0,tick=0;
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now(),dt=Math.min((now-last)/1000,.05);
  last=now; tick++; frames++; fpsT+=dt;
  if(fpsT>=.5){fps=Math.round(frames/fpsT);frames=0;fpsT=0;}
  if(locked && !isDead) movePlayer(dt);
  if(!isDead) {
    updateDayNight(dt);
    updateMobs(dt);
    processPhysics();
    updateAutoSave(dt);
  }

  // Clouds follow player
  if(tick%4===0) {
    cloudMeshes.forEach((c,i)=>{
      c.position.x = player.pos.x + cloudOffsets[i].x;
      c.position.z = player.pos.z + cloudOffsets[i].z;
    });
  }

  // Sounds
  if(locked) {
    const moving = keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD'];
    updateFootsteps(dt, moving);
    updateAmbient(dt);
    const inW2 = isPlayerInWater();
    if(inW2 && !wasInWater) playWaterSound();
    wasInWater = inW2;
  }

  // Underwater tint overlay
  const inW = isPlayerInWater();
  renderer.domElement.style.filter = inW ? 'hue-rotate(180deg) saturate(1.5) brightness(0.7)' : '';
  const[pcx,pcz]=worldToChunk(player.pos.x,player.pos.z);
  if(pcx!==lastPCX||pcz!==lastPCZ){updateChunks(player.pos.x,player.pos.z);lastPCX=pcx;lastPCZ=pcz;}
  processMeshQueue(4);
  camera.position.copy(player.pos).add(new THREE.Vector3(0,player.EYE,0));
  camera.rotation.set(pitch,yaw,0,'YXZ');
  const rc=raycast();
  if(rc&&locked){hlMesh.position.set(rc.hit.x+.5,rc.hit.y+.5,rc.hit.z+.5);hlMesh.visible=true;}
  else hlMesh.visible=false;
  if(tick%30===0){
    const p=player.pos;
    document.getElementById('pos').textContent=`XYZ: ${Math.floor(p.x)} / ${Math.floor(p.y)} / ${Math.floor(p.z)}`;
    document.getElementById('chunk-info').textContent=`Chunk: ${pcx}, ${pcz}`;
    document.getElementById('fps').textContent=`FPS: ${fps}`;
    document.getElementById('chunk-count').textContent=`Chunks: ${chunks.size} | Queue: ${pendingMeshRebuild.size}`;
    // Biome name
    const bname=['Llanura','Desierto','Tundra','Bosque','Oc√©ano','Monta√±a'];
    const cb=getBiome(Math.floor(p.x),Math.floor(p.z));
    document.getElementById('chunk-info').textContent=`Chunk: ${pcx},${pcz}  |  ${bname[cb]}`;
    // Blend fog toward biome tint
    const tgt=new THREE.Color(BIOME_TINT[cb]);
    currentBiomeTint.lerp(tgt, 0.05);
    if(!isPlayerInWater()) scene.fog.color.lerp(currentBiomeTint, 0.08);
  }
  if(tick%60===0) drawMinimap();
  if(tick%120===0 && !isDead) updateObjectives();
  renderer.render(scene,camera);
}

// ‚îÄ‚îÄ SOUND SYSTEM (Web Audio API ‚Äî no files) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let audioCtx = null;
function getAudioCtx() {
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  return audioCtx;
}

function playTone(freq, type, duration, vol=0.15, attack=0.01, decay=0.1) {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type = type; osc.frequency.value = freq;
    const t = ctx.currentTime;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(vol, t+attack);
    gain.gain.exponentialRampToValueAtTime(0.001, t+duration);
    osc.start(t); osc.stop(t+duration+0.05);
  } catch(e){}
}

function playNoise(duration, vol=0.08, filterFreq=800) {
  try {
    const ctx = getAudioCtx();
    const bufSize = ctx.sampleRate * duration;
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<bufSize;i++) data[i] = Math.random()*2-1;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass'; filter.frequency.value = filterFreq;
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+duration);
    src.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    src.start(); src.stop(ctx.currentTime+duration);
  } catch(e){}
}

// Block break sounds by type
function playBreakSound(blockType) {
  switch(blockType) {
    case B.GRASS:  playNoise(0.12, 0.12, 600); break;
    case B.DIRT:   playNoise(0.10, 0.10, 400); break;
    case B.STONE:  playTone(180, 'sawtooth', 0.12, 0.12); playNoise(0.08, 0.06, 1200); break;
    case B.SAND:   playNoise(0.08, 0.09, 300); break;
    case B.GRAVEL: playNoise(0.10, 0.10, 500); break;
    case B.LOG:    playNoise(0.14, 0.11, 700); break;
    case B.LEAVES: playNoise(0.07, 0.08, 900); break;
    case B.SNOW:   playNoise(0.06, 0.07, 200); break;
    default:       playNoise(0.10, 0.10, 500);
  }
}

// Block place sound
function playPlaceSound(blockType) {
  switch(blockType) {
    case B.STONE:  playTone(220, 'square', 0.08, 0.08); break;
    case B.SAND:   playNoise(0.06, 0.07, 350); break;
    case B.WATER:  playTone(180, 'sine', 0.15, 0.1); break;
    default:       playNoise(0.07, 0.08, 600);
  }
}

// Footstep sounds
let stepTimer = 0;
const STEP_INTERVAL = 0.38;
function updateFootsteps(dt, moving) {
  if(!moving || !player.onGround) { stepTimer=0; return; }
  stepTimer += dt;
  if(stepTimer >= STEP_INTERVAL) {
    stepTimer = 0;
    const underBlock = getBlock(Math.floor(player.pos.x), Math.floor(player.pos.y)-1, Math.floor(player.pos.z));
    switch(underBlock) {
      case B.GRASS:  playNoise(0.09, 0.07, 500); break;
      case B.DIRT:   playNoise(0.08, 0.06, 350); break;
      case B.STONE:  playTone(200+Math.random()*40,'square',0.06,0.05); break;
      case B.SAND:   playNoise(0.07, 0.05, 280); break;
      case B.SNOW:   playNoise(0.06, 0.06, 180); break;
      case B.GRAVEL: playNoise(0.09, 0.07, 450); break;
      default:       playNoise(0.07, 0.05, 400);
    }
  }
}

// Ambient biome sounds ‚Äî random environmental tones
let ambientTimer = 0;
function updateAmbient(dt) {
  ambientTimer -= dt;
  if(ambientTimer > 0) return;
  const biome = getBiome(Math.floor(player.pos.x), Math.floor(player.pos.z));
  const isNight = timeOfDay<0.25||timeOfDay>0.75;
  switch(biome) {
    case BIOME.FOREST:
      // Bird chirps
      playTone(800+Math.random()*400, 'sine', 0.15, 0.04);
      setTimeout(()=>playTone(1000+Math.random()*300,'sine',0.1,0.03), 120);
      ambientTimer = 4+Math.random()*5;
      break;
    case BIOME.OCEAN:
      // Wave rumble
      playNoise(0.6, 0.04, 150);
      ambientTimer = 3+Math.random()*4;
      break;
    case BIOME.DESERT:
      // Wind hiss
      playNoise(0.3, 0.03, 1800);
      ambientTimer = 6+Math.random()*8;
      break;
    case BIOME.TUNDRA:
    case BIOME.MOUNTAIN:
      // Wind howl
      playTone(60+Math.random()*30,'sine',0.5,0.03);
      ambientTimer = 5+Math.random()*7;
      break;
    default:
      if(isNight) {
        // Cricket-like
        playTone(900,'square',0.05,0.02);
        setTimeout(()=>playTone(900,'square',0.05,0.02), 100);
        ambientTimer = 2+Math.random()*3;
      } else {
        ambientTimer = 5+Math.random()*6;
      }
  }
}

// Water splash
function playWaterSound() { playTone(200,'sine',0.3,0.08); playNoise(0.2,0.06,400); }
let wasInWater = false;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ OBJECTIVE / PROGRESSION SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const OBJECTIVES = [
  { id:'mine_wood',    text:'Tala tu primer √°rbol',      check:()=> countInInventory(B.LOG)  >= 1 },
  { id:'craft_pick',  text:'Craftea un Pico de Madera', check:()=> countInInventory(10)     >= 1 },
  { id:'mine_stone',  text:'Mina 10 bloques de piedra',  check:()=> _stats.stoneMined        >= 10 },
  { id:'craft_sword', text:'Craftea una Espada',         check:()=> countInInventory(13)     >= 1 },
  { id:'kill_mob',    text:'Derrota a un mob hostil',    check:()=> _stats.mobsKilled        >= 1 },
  { id:'survive',     text:'Sobrevive una noche entera', check:()=> _stats.nightsSurvived    >= 1 },
  { id:'build',       text:'Coloca 20 bloques',          check:()=> _stats.blocksPlaced      >= 20 },
];

const _stats = { stoneMined:0, mobsKilled:0, nightsSurvived:0, blocksPlaced:0, _wasNight:false };
const completedObjs = new Set();

function updateObjectives() {
  const isNight = timeOfDay < 0.25 || timeOfDay > 0.75;
  if(_stats._wasNight && !isNight) _stats.nightsSurvived++;
  _stats._wasNight = isNight;
  let changed = false;
  for(const obj of OBJECTIVES) {
    if(!completedObjs.has(obj.id) && obj.check()) {
      completedObjs.add(obj.id);
      showHUDMessage(`‚úÖ ${obj.text}`, 3000);
      playTone(660,'sine',0.2,0.1); setTimeout(()=>playTone(880,'sine',0.15,0.08),120);
      changed = true;
    }
  }
  if(changed) renderObjectives();
}

function renderObjectives() {
  const list = document.getElementById('obj-list');
  if(!list) return;
  list.innerHTML = '';
  let shownCurrent = false;
  for(const obj of OBJECTIVES) {
    const done = completedObjs.has(obj.id);
    if(done) {
      const el=document.createElement('div');
      el.className='obj-done'; el.textContent='‚úì '+obj.text;
      list.appendChild(el);
    } else if(!shownCurrent) {
      const el=document.createElement('div');
      el.className='obj-curr'; el.textContent='‚ñ∂ '+obj.text;
      list.appendChild(el);
      shownCurrent = true;
    }
  }
  if(completedObjs.size===OBJECTIVES.length) {
    const el=document.createElement('div');
    el.style.cssText='color:#ffd700;margin-top:4px;';
    el.textContent='üèÜ ¬°Todos completados!';
    list.appendChild(el);
  }
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ HUD FEEDBACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _hudMsgTimer = null;
function showHUDMessage(text, duration=2200) {
  const el = document.getElementById('hud-msg');
  el.textContent = text;
  el.style.color = 'rgba(255,220,80,0.92)';
  if(_hudMsgTimer) clearTimeout(_hudMsgTimer);
  _hudMsgTimer = setTimeout(()=>{ el.style.color='rgba(255,220,80,0)'; }, duration);
}

// ‚îÄ‚îÄ DEATH / RESPAWN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let isDead = false;
let spawnX = 8.5, spawnY = 30, spawnZ = 8.5; // set properly after findSpawn

function triggerDeath() {
  if(isDead) return;
  isDead = true;
  document.exitPointerLock();
  const screen = document.getElementById('death-screen');
  screen.style.display = 'flex';
  const msgs = [
    'Los zombies te encontraron en la oscuridad.',
    'Ca√≠ste al vac√≠o.',
    'Los esqueletos te rodearon.',
    'Aventurero inexperto.',
  ];
  document.getElementById('death-msg').textContent = msgs[Math.floor(Math.random()*msgs.length)];
  playTone(80,'sawtooth',1.2,0.15);
}

function respawn() {
  isDead = false;
  playerHP = playerMaxHP;
  player.pos.set(spawnX, spawnY+2, spawnZ);
  player.vel.set(0,0,0);
  document.getElementById('death-screen').style.display = 'none';
  renderer.domElement.requestPointerLock();
  updateHealthBar();
  showHUDMessage('‚Ü© Reapareciste en el spawn');
}

document.getElementById('respawn-btn').addEventListener('click', respawn);
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SAVE_KEY = 'voxelcraft_save_v1';
const SAVE_INTERVAL = 30; // seconds
let saveTimer = 0;

function saveGame() {
  try {
    // Solo chunks modificados (dirty flag) para no superar el l√≠mite de localStorage
    const chunkData = {};
    for(const [key, chunk] of chunks) {
      if(chunk.dirty) chunkData[key] = Array.from(chunk.data);
    }
    const saveObj = {
      player:    { x: player.pos.x, y: player.pos.y, z: player.pos.z },
      yaw, pitch,
      inventory,
      hotbarInv,
      timeOfDay,
      chunks:    chunkData,
      savedAt:   Date.now(),
    };
    const json = JSON.stringify(saveObj);
    // Guard: warn if approaching limit (5MB)
    if(json.length > 4_000_000) {
      showHUDMessage('‚ö† Guardado parcial ‚Äî muchos chunks modificados');
    }
    localStorage.setItem(SAVE_KEY, json);
    showSaveIndicator();
  } catch(e) {
    showHUDMessage('‚ùå Error al guardar: ' + (e.name==='QuotaExceededError' ? 'Sin espacio en disco' : e.message));
    console.warn('Save failed:', e);
  }
}

function loadGame() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return false;
    const save = JSON.parse(raw);
    // Restore player
    player.pos.set(save.player.x, save.player.y, save.player.z);
    yaw   = save.yaw   || 0;
    pitch = save.pitch || 0;
    // Restore inventory
    if(save.inventory) save.inventory.forEach((s,i)=>{ inventory[i]=s; });
    if(save.hotbarInv) save.hotbarInv.forEach((s,i)=>{ hotbarInv[i]=s; });
    if(save.timeOfDay !== undefined) timeOfDay = save.timeOfDay;
    // Restore chunks
    if(save.chunks) {
      for(const [key, dataArr] of Object.entries(save.chunks)) {
        const [cx,cz] = key.split(',').map(Number);
        const data = new Uint8Array(dataArr);
        chunks.set(key, { data, meshes:[], generated:true });
        pendingMeshRebuild.add(key);
      }
    }
    return true;
  } catch(e) { console.warn('Load failed:', e); return false; }
}

function deleteSave() {
  localStorage.removeItem(SAVE_KEY);
  location.reload();
}

function showSaveIndicator() {
  const el = document.getElementById('save-indicator');
  el.style.color = 'rgba(255,255,255,0.85)';
  setTimeout(()=>{ el.style.color='rgba(255,255,255,0)'; }, 1800);
}

function updateAutoSave(dt) {
  if(!locked) return;
  saveTimer += dt;
  if(saveTimer >= SAVE_INTERVAL) { saveTimer=0; saveGame(); }
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ CRAFTING SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HERRAMIENTAS como tipo especial de item
// A√±adimos IDs de tool: 10=pico_madera, 11=pico_piedra, 12=hacha, 13=espada_madera
const TOOLS = {
  10: { name:'Pico de Madera', breakBonus:{ [B.STONE]:true }, emoji:'‚õèÔ∏è' },
  11: { name:'Pico de Piedra', breakBonus:{ [B.STONE]:true, [B.GRAVEL]:true }, emoji:'‚õèÔ∏è' },
  12: { name:'Hacha',          breakBonus:{ [B.LOG]:true, [B.LEAVES]:true }, emoji:'ü™ì' },
  13: { name:'Espada',         attackBonus:3, emoji:'‚öîÔ∏è' },
};
// Extender BDATA para tools
Object.entries(TOOLS).forEach(([id,t])=>{ BDATA[parseInt(id)]={ name:t.name, tool:true }; });

const RECIPES = [
  // CADENA DE PROGRESI√ìN:
  // Paso 1: madera bruta ‚Üí tablas (fundamental)
  { name:'Tablas de Madera', ingredients:[{type:B.LOG,count:1}],
    result:{type:B.LOG,count:4}, emoji:'ü™µ',
    desc:'Base para todo el crafteo' },

  // Paso 2: tablas ‚Üí pico de madera (abre miner√≠a de piedra)
  { name:'Pico de Madera', ingredients:[{type:B.LOG,count:3},{type:B.DIRT,count:2}],
    result:{type:10,count:1}, emoji:'‚õèÔ∏è',
    desc:'Mina piedra m√°s r√°pido' },

  // Paso 3: pico de madera + piedra ‚Üí pico de piedra
  { name:'Pico de Piedra', ingredients:[{type:B.STONE,count:3},{type:B.LOG,count:2}],
    result:{type:11,count:1}, emoji:'‚õèÔ∏è',
    desc:'M√°s resistente que madera' },

  // Paso 4: hacha de madera (para cortar √°rboles r√°pido)
  { name:'Hacha de Madera', ingredients:[{type:B.LOG,count:2},{type:B.DIRT,count:1}],
    result:{type:12,count:1}, emoji:'ü™ì',
    desc:'Rompe madera y hojas al instante' },

  // Paso 5: espada para combatir mobs
  { name:'Espada de Madera', ingredients:[{type:B.LOG,count:2},{type:B.GRAVEL,count:1}],
    result:{type:13,count:1}, emoji:'‚öîÔ∏è',
    desc:'+3 da√±o extra a mobs' },

  // Utilidad: arena compactada ‚Üí grava (tiene sentido geol√≥gico)
  { name:'Arena ‚Üí Grava', ingredients:[{type:B.SAND,count:4}],
    result:{type:B.GRAVEL,count:2}, emoji:'ü™®',
    desc:'Compactar arena en grava' },

  // Utilidad: nieve ‚Üí agua (derretir)
  { name:'Derretir Nieve', ingredients:[{type:B.SNOW,count:4}],
    result:{type:B.WATER,count:1}, emoji:'üíß',
    desc:'La nieve se convierte en agua' },

  // Utilidad: madera + tierra ‚Üí hojas decorativas
  { name:'Hojas Decorativas', ingredients:[{type:B.LOG,count:1},{type:B.DIRT,count:2}],
    result:{type:B.LEAVES,count:8}, emoji:'üåø',
    desc:'Para construcci√≥n y decoraci√≥n' },
];

let craftOpen = false;

function countInInventory(type) {
  let total = 0;
  inventory.forEach(s=>{ if(s?.type===type) total+=s.count; });
  hotbarInv.forEach(s=>{ if(s?.type===type) total+=s.count; });
  return total;
}

function canCraft(recipe) {
  // Group needed
  const needed = {};
  recipe.ingredients.forEach(i=>{ needed[i.type]=(needed[i.type]||0)+i.count; });
  for(const [type,count] of Object.entries(needed)) {
    if(countInInventory(parseInt(type)) < count) return false;
  }
  return true;
}

function doCraft(recipe) {
  if(!canCraft(recipe)) { playTone(120,'sawtooth',0.15,0.1); return; }
  // Consume ingredients from hotbar first, then backpack
  const needed = {};
  recipe.ingredients.forEach(i=>{ needed[i.type]=(needed[i.type]||0)+i.count; });
  for(const [type, count] of Object.entries(needed)) {
    let rem = count;
    for(const arr of [hotbarInv, inventory]) {
      for(let i=0;i<arr.length&&rem>0;i++) {
        if(arr[i]?.type===parseInt(type)) {
          const take=Math.min(rem,arr[i].count);
          arr[i].count-=take; rem-=take;
          if(arr[i].count<=0) arr[i]=null;
        }
      }
    }
  }
  addToInventory(recipe.result.type, recipe.result.count);
  playTone(660,'sine',0.2,0.12); setTimeout(()=>playTone(880,'sine',0.15,0.08),120);
  buildHotbarUI(); refreshHotbar();
  renderCraftUI();
  updateObjectives();
}

function openCraft() {
  craftOpen=true;
  document.exitPointerLock();
  document.getElementById('craft-screen').style.display='block';
  renderCraftUI();
}
function closeCraft() {
  craftOpen=false;
  document.getElementById('craft-screen').style.display='none';
  renderer.domElement.requestPointerLock();
}

// Track which recipes were available last time ‚Äî notify on new ones
let _prevAvailableRecipes = new Set();
function checkNewRecipes() {
  const now = new Set(RECIPES.filter(r=>canCraft(r)).map(r=>r.name));
  for(const name of now) {
    if(!_prevAvailableRecipes.has(name)) {
      showHUDMessage(`üî® Nuevo crafteo disponible: ${name}`);
    }
  }
  _prevAvailableRecipes = now;
}

function renderCraftUI() {
  const list = document.getElementById('craft-list');
  list.innerHTML = '';
  RECIPES.forEach((r,ri) => {
    const ok = canCraft(r);
    const row = document.createElement('div');
    row.className = 'craft-row';
    row.title = ok ? 'Click para craftear' : 'Ingredientes insuficientes';

    const recipe = document.createElement('div');
    recipe.className='recipe';
    r.ingredients.forEach(ing=>{
      const slot=document.createElement('div');
      slot.className='craft-ingr';
      const img=document.createElement('img');
      img.src=getBlockPreviewCanvas(ing.type);
      slot.appendChild(img);
      const qty=document.createElement('div');
      qty.className='craft-qty'; qty.textContent=`x${ing.count}`;
      const wrap=document.createElement('div'); wrap.style.display='flex';wrap.style.flexDirection='column';wrap.style.alignItems='center';
      wrap.appendChild(slot); wrap.appendChild(qty);
      recipe.appendChild(wrap);
    });

    const arrow=document.createElement('span'); arrow.className='arrow'; arrow.textContent='‚Üí';
    const resultWrap=document.createElement('div'); resultWrap.className='result';
    const rSlot=document.createElement('div'); rSlot.className='craft-ingr';
    const rImg=document.createElement('img'); rImg.src=getBlockPreviewCanvas(r.result.type);
    rSlot.appendChild(rImg); resultWrap.appendChild(rSlot);
    const rName=document.createElement('span'); rName.textContent=`${r.emoji} ${r.name} x${r.result.count}`;
    resultWrap.appendChild(rName);
    if(r.desc) {
      const desc=document.createElement('span');
      desc.style.cssText='font-size:9px;color:rgba(255,255,100,.5);margin-top:2px;';
      desc.textContent=r.desc;
      resultWrap.appendChild(desc);
    }

    const status=document.createElement('span');
    status.className='craft-status '+(ok?'ok':'no');
    status.textContent=ok?'‚úì Craftear':'‚úó Falta';

    row.appendChild(recipe); row.appendChild(arrow); row.appendChild(resultWrap); row.appendChild(status);
    if(ok) row.addEventListener('click',()=>doCraft(r));
    list.appendChild(row);
  });
}

document.getElementById('craft-close').addEventListener('click', closeCraft);
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ IMPROVED SOUNDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Replace basic tones with richer layered sounds
function playBreakSound(blockType) {
  const ctx=getAudioCtx(), t=ctx.currentTime;
  switch(blockType) {
    case B.GRASS:
      playNoise(0.12,0.10,500); playNoise(0.06,0.05,900);
      break;
    case B.DIRT:
      playNoise(0.10,0.09,380); playTone(90,'sine',0.08,0.04);
      break;
    case B.STONE:
      playNoise(0.08,0.06,1400); playTone(160,'sawtooth',0.1,0.08);
      setTimeout(()=>playNoise(0.06,0.04,800),60);
      break;
    case B.SAND:
      playNoise(0.09,0.08,280); playNoise(0.05,0.04,600);
      break;
    case B.LOG:
      playNoise(0.14,0.10,650); playTone(110,'triangle',0.12,0.06);
      break;
    case B.LEAVES:
      playNoise(0.07,0.07,1100); playNoise(0.05,0.04,1600);
      break;
    case B.SNOW:
      playNoise(0.06,0.06,200); playTone(300,'sine',0.08,0.03);
      break;
    case B.GRAVEL:
      playNoise(0.10,0.09,480); playNoise(0.07,0.06,700);
      break;
    default: playNoise(0.10,0.08,500);
  }
}

function playPlaceSound(blockType) {
  switch(blockType) {
    case B.STONE: playTone(180,'square',0.09,0.07); playNoise(0.05,0.04,900); break;
    case B.SAND:  playNoise(0.07,0.06,300); break;
    case B.WATER: playTone(160,'sine',0.18,0.09); playNoise(0.15,0.05,350); break;
    case B.LOG:   playNoise(0.08,0.07,600); playTone(120,'triangle',0.1,0.05); break;
    default:      playNoise(0.07,0.07,550);
  }
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ WINDOW / RESIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INIT
window.addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

const hasSave = loadGame();
updateChunks(player.pos.x, player.pos.z);
processMeshQueue(999);
if(!hasSave) findSpawn();
initialSpawnMobs();
updateHealthBar();
buildHotbarUI();
refreshHotbar();
renderObjectives();
animate();
</script>
</body>
</html>
